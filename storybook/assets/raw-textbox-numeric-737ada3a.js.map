{"version":3,"file":"raw-textbox-numeric-737ada3a.js","sources":["../../../utilities/lib/number/private/regex.js","../../../utilities/lib/number/evaluate-numeric-expression.js","../../../utilities/lib/number/is-valid-numeric-input.js","../../src/components/textbox/textbox-numeric/private/format-evaluated-value.ts","../../src/components/textbox/textbox-numeric/private/raw-textbox-numeric.tsx"],"sourcesContent":["export const floatOperandRegex = /^-?\\d*(?:\\.\\d*)?$/;\nexport const integerOperandRegex = /^-?\\d*$/;\nexport const operatorRegex = /[+\\-*/]/;\nexport const operatorSuffixRegex = /[+\\-*/]$/;\nexport const numbersRegex = /\\d/;\nexport const invalidCharactersRegex = /[^\\d.+\\-*/]/;\n//# sourceMappingURL=regex.js.map","import { invalidCharactersRegex, numbersRegex, operatorRegex, operatorSuffixRegex } from './private/regex.js';\nexport function evaluateNumericExpression(value) {\n    if (value === '' ||\n        numbersRegex.test(value) === false ||\n        invalidCharactersRegex.test(value) === true) {\n        return null;\n    }\n    if (operatorRegex.test(value) === true) {\n        if (operatorSuffixRegex.test(value) === true) {\n            return eval(value.substring(0, value.length - 1));\n        }\n        return eval(value);\n    }\n    return parseFloat(value);\n}\n//# sourceMappingURL=evaluate-numeric-expression.js.map","import { floatOperandRegex, integerOperandRegex, operatorRegex } from './private/regex.js';\nexport function isValidNumericInput(value, options = { integersOnly: false }) {\n    const split = (value[0] === '-' ? value.substring(1) : value).split(operatorRegex);\n    let i = -1;\n    while (++i < split.length) {\n        const operand = split[i];\n        if ((operand === '' && i !== split.length - 1) ||\n            (options.integersOnly === true\n                ? integerOperandRegex\n                : floatOperandRegex).test(operand) === false) {\n            return false;\n        }\n    }\n    return true;\n}\n//# sourceMappingURL=is-valid-numeric-input.js.map","const EMPTY_STRING = ''\n\nconst fractionalPartRegex = /\\.([^.]+)/\nconst nonDigitRegex = /[^\\d.]/\n\nexport function formatEvaluatedValue(\n  evaluatedValue: null | number,\n  value: string,\n  suffix?: string\n): string {\n  if (evaluatedValue === null) {\n    return EMPTY_STRING\n  }\n  const significantFiguresCount = countSignificantFigures(\n    nonDigitRegex.test(value) === true ? `${evaluatedValue}` : value\n  )\n  return appendSuffix(\n    formatSignificantFigures(evaluatedValue, significantFiguresCount),\n    suffix\n  )\n}\n\nfunction countSignificantFigures(value: string): number {\n  const result = fractionalPartRegex.exec(value)\n  if (result === null) {\n    return 0\n  }\n  return result[1].length\n}\n\nfunction formatSignificantFigures(\n  value: number,\n  significantFiguresCount: number\n): string {\n  if (significantFiguresCount === 0) {\n    return `${value}`\n  }\n  const result = fractionalPartRegex.exec(`${value}`)\n  if (result === null) {\n    return `${value}.${'0'.repeat(significantFiguresCount)}`\n  }\n  const fractionalPart = result[1]\n  const count = significantFiguresCount - fractionalPart.length\n  return `${value}${'0'.repeat(count)}`\n}\n\nfunction appendSuffix(string: string, suffix?: string): string {\n  if (typeof suffix === 'undefined') {\n    return string\n  }\n  if (string === EMPTY_STRING) {\n    return EMPTY_STRING\n  }\n  return `${string}${suffix}`\n}\n","import {\n  evaluateNumericExpression,\n  isValidNumericInput,\n  MIXED_NUMBER,\n  MIXED_STRING\n} from '@create-figma-plugin/utilities'\nimport { h, RefObject } from 'preact'\nimport { useCallback, useRef, useState } from 'preact/hooks'\n\nimport { Event, EventHandler } from '../../../../types/event-handler.js'\nimport { FocusableComponentProps } from '../../../../types/focusable-component-props.js'\nimport { createComponent } from '../../../../utilities/create-component.js'\nimport { getCurrentFromRef } from '../../../../utilities/get-current-from-ref.js'\nimport { noop } from '../../../../utilities/no-op.js'\nimport { computeNextValue } from '../../private/compute-next-value.js'\nimport { isKeyCodeCharacterGenerating } from '../../private/is-keycode-character-generating.js'\nimport { formatEvaluatedValue } from './format-evaluated-value.js'\n\nconst FRACTION_DIGITS = 3\nconst EMPTY_STRING = ''\n\nexport interface RawTextboxNumericProps\n  extends FocusableComponentProps<HTMLInputElement> {\n  disabled?: boolean\n  incrementBig?: number\n  incrementSmall?: number\n  integer?: boolean\n  maximum?: number\n  minimum?: number\n  onBlur?: EventHandler.onBlur<HTMLInputElement>\n  onFocus?: EventHandler.onFocus<HTMLInputElement>\n  onInput?: EventHandler.onInput<HTMLInputElement>\n  onMouseDown?: EventHandler.onMouseUp<HTMLInputElement>\n  onNumericValueInput?: EventHandler.onValueChange<null | number>\n  onValueInput?: EventHandler.onValueChange<string>\n  placeholder?: string\n  revertOnEscapeKeyDown?: boolean\n  suffix?: string\n  validateOnBlur?: (value: null | number) => null | number | boolean\n  value: string\n}\n\nexport const RawTextboxNumeric = createComponent<\n  HTMLInputElement,\n  RawTextboxNumericProps\n>(function (\n  {\n    disabled = false,\n    incrementBig = 10,\n    incrementSmall = 1,\n    integer = false,\n    maximum,\n    minimum,\n    onBlur = noop,\n    onFocus = noop,\n    onInput = noop,\n    onMouseDown = noop,\n    onKeyDown = noop,\n    onNumericValueInput = noop,\n    onValueInput = noop,\n    placeholder,\n    propagateEscapeKeyDown = true,\n    revertOnEscapeKeyDown = false,\n    suffix,\n    validateOnBlur,\n    value,\n    ...rest\n  },\n  ref\n) {\n  if (\n    typeof minimum !== 'undefined' &&\n    typeof maximum !== 'undefined' &&\n    minimum >= maximum\n  ) {\n    throw new Error('`minimum` must be less than `maximum`')\n  }\n\n  const inputElementRef: RefObject<HTMLInputElement> = useRef(null)\n  const revertOnEscapeKeyDownRef: RefObject<boolean> = useRef(false) // Set to `true` when the `Escape` key is pressed; used to bail out of `handleBlur`\n\n  const [originalValue, setOriginalValue] = useState(EMPTY_STRING) // Value of the textbox when it was initially focused\n\n  const setInputElementValue = useCallback(function (value: string) {\n    const inputElement = getCurrentFromRef(inputElementRef)\n    inputElement.value = value\n    const inputEvent = new window.Event('input', {\n      bubbles: true,\n      cancelable: true\n    })\n    inputElement.dispatchEvent(inputEvent)\n  }, [])\n\n  const handleBlur = useCallback(\n    function (event: Event.onBlur<HTMLInputElement>) {\n      onBlur(event)\n      if (revertOnEscapeKeyDownRef.current === true) {\n        revertOnEscapeKeyDownRef.current = false\n        return\n      }\n      if (typeof validateOnBlur !== 'undefined') {\n        const evaluatedValue = evaluateValue(value, suffix)\n        const result = validateOnBlur(evaluatedValue)\n        if (typeof result === 'number') {\n          // Set to the value returned by `validateOnBlur`\n          setInputElementValue(formatEvaluatedValue(result, value, suffix))\n          setOriginalValue(EMPTY_STRING)\n          return\n        }\n        if (result === null) {\n          // Set value to the empty string\n          setInputElementValue(EMPTY_STRING)\n          setOriginalValue(EMPTY_STRING)\n          return\n        }\n        if (result === false) {\n          // Revert the original value\n          if (value !== originalValue) {\n            setInputElementValue(originalValue)\n          }\n          setOriginalValue(EMPTY_STRING)\n          return\n        }\n      }\n      if (typeof suffix !== 'undefined' && value === suffix) {\n        // We don't want a textbox to contain just the `suffix`, so clear the `value`\n        setInputElementValue(EMPTY_STRING)\n        setOriginalValue(EMPTY_STRING)\n        return\n      }\n      if (value !== EMPTY_STRING && value !== MIXED_STRING) {\n        const evaluatedValue = evaluateValue(value, suffix)\n        const formattedValue = formatEvaluatedValue(\n          evaluatedValue,\n          value,\n          suffix\n        )\n        if (value !== formattedValue) {\n          setInputElementValue(formattedValue)\n        }\n      }\n      setOriginalValue(EMPTY_STRING)\n    },\n    [onBlur, originalValue, setInputElementValue, suffix, validateOnBlur, value]\n  )\n\n  const handleFocus = useCallback(\n    function (event: Event.onFocus<HTMLInputElement>) {\n      onFocus(event)\n      setOriginalValue(value)\n      event.currentTarget.select()\n    },\n    [onFocus, value]\n  )\n\n  const handleInput = useCallback(\n    function (event: Event.onInput<HTMLInputElement>) {\n      onInput(event)\n      const newValue = event.currentTarget.value\n      onValueInput(newValue)\n      const evaluatedValue = evaluateValue(newValue, suffix)\n      onNumericValueInput(evaluatedValue)\n    },\n    [onInput, onNumericValueInput, onValueInput, suffix]\n  )\n\n  const handleKeyDown = useCallback(\n    function (event: Event.onKeyDown<HTMLInputElement>) {\n      onKeyDown(event)\n      const key = event.key\n      if (key === 'Escape') {\n        if (revertOnEscapeKeyDown === true) {\n          revertOnEscapeKeyDownRef.current = true\n          setInputElementValue(originalValue)\n          setOriginalValue(EMPTY_STRING)\n        }\n        if (propagateEscapeKeyDown === false) {\n          event.stopPropagation()\n        }\n        event.currentTarget.blur()\n        return\n      }\n      const inputElement = event.currentTarget\n      if (key === 'ArrowDown' || key === 'ArrowUp') {\n        const delta = event.shiftKey === true ? incrementBig : incrementSmall\n        event.preventDefault()\n        if (value === EMPTY_STRING || value === MIXED_STRING) {\n          // `startingValue` is biased towards 0\n          const startingValue = (function () {\n            if (typeof minimum !== 'undefined' && minimum > 0) {\n              return minimum\n            }\n            if (typeof maximum !== 'undefined' && maximum < 0) {\n              return maximum\n            }\n            return 0\n          })()\n          const evaluatedValue = evaluateValueWithDelta(\n            startingValue,\n            key === 'ArrowDown' ? -1 * delta : delta\n          )\n          const newValue = restrictValue(evaluatedValue, minimum, maximum)\n          const formattedValue = formatEvaluatedValue(newValue, value, suffix)\n          inputElement.value = formattedValue\n          inputElement.select()\n          handleInput(event)\n          return\n        }\n        const number = evaluateValue(value, suffix)\n        if (number === null) {\n          throw new Error('`number` is `null`')\n        }\n        const evaluatedValue = evaluateValueWithDelta(\n          number,\n          key === 'ArrowDown' ? -1 * delta : delta\n        )\n        const newValue = restrictValue(evaluatedValue, minimum, maximum)\n        const formattedValue = formatEvaluatedValue(newValue, value, suffix)\n        if (formattedValue === value) {\n          return\n        }\n        inputElement.value = formattedValue\n        inputElement.select()\n        handleInput(event)\n        return\n      }\n      if (event.ctrlKey === true || event.metaKey === true) {\n        return\n      }\n      if (isKeyCodeCharacterGenerating(event.keyCode) === true) {\n        // Piece together `newValue` using the key that was pressed, and stop\n        // the `keyDown` event (by calling `event.preventDefault()`) if\n        // `newValue` is found to be invalid\n        const newValue = trimSuffix(\n          value === MIXED_STRING\n            ? event.key\n            : computeNextValue(inputElement, event.key),\n          suffix\n        )\n        if (\n          isValidNumericInput(newValue, { integersOnly: integer }) === false\n        ) {\n          event.preventDefault()\n          return\n        }\n        if (typeof minimum === 'undefined' && typeof maximum === 'undefined') {\n          return\n        }\n        const evaluatedValue = evaluateNumericExpression(newValue)\n        if (evaluatedValue === null) {\n          return\n        }\n        if (\n          (typeof minimum !== 'undefined' && evaluatedValue < minimum) ||\n          (typeof maximum !== 'undefined' && evaluatedValue > maximum)\n        ) {\n          event.preventDefault()\n        }\n      }\n    },\n    [\n      handleInput,\n      incrementBig,\n      incrementSmall,\n      integer,\n      maximum,\n      minimum,\n      onKeyDown,\n      originalValue,\n      propagateEscapeKeyDown,\n      revertOnEscapeKeyDown,\n      setInputElementValue,\n      suffix,\n      value\n    ]\n  )\n\n  const handleMouseDown = useCallback(\n    function (event: Event.onMouseUp<HTMLInputElement>) {\n      onMouseDown(event)\n      if (value === MIXED_STRING) {\n        // Prevent changing the selection if `value` is `MIXED_STRING`\n        event.preventDefault()\n        event.currentTarget.select()\n      }\n    },\n    [onMouseDown, value]\n  )\n\n  const handlePaste = useCallback(\n    function (event: Event.onPaste<HTMLInputElement>) {\n      if (event.clipboardData === null) {\n        throw new Error('`event.clipboardData` is `null`')\n      }\n      const nextValue = trimSuffix(\n        computeNextValue(\n          event.currentTarget,\n          event.clipboardData.getData('Text')\n        ),\n        suffix\n      )\n      if (\n        isValidNumericInput(nextValue, {\n          integersOnly: integer\n        }) === false\n      ) {\n        event.preventDefault()\n      }\n    },\n    [integer, suffix]\n  )\n\n  const refCallback = useCallback(\n    function (inputElement: null | HTMLInputElement) {\n      inputElementRef.current = inputElement\n      if (ref === null) {\n        return\n      }\n      if (typeof ref === 'function') {\n        ref(inputElement)\n        return\n      }\n      ref.current = inputElement\n    },\n    [ref]\n  )\n\n  return (\n    <input\n      {...rest}\n      ref={refCallback}\n      disabled={disabled === true}\n      onBlur={handleBlur}\n      onFocus={handleFocus}\n      onInput={handleInput}\n      onKeyDown={handleKeyDown}\n      onMouseDown={handleMouseDown}\n      onPaste={handlePaste}\n      placeholder={placeholder}\n      spellcheck={false}\n      tabIndex={0}\n      type=\"text\"\n      value={value === MIXED_STRING ? 'Mixed' : value}\n    />\n  )\n})\n\nfunction restrictValue(value: number, minimum?: number, maximum?: number) {\n  if (typeof minimum !== 'undefined') {\n    if (typeof maximum !== 'undefined') {\n      // both `minimum` and `maximum` are defined\n      return Math.min(Math.max(value, minimum), maximum)\n    }\n    // only `minimum` is defined\n    return Math.max(value, minimum)\n  }\n  if (typeof maximum !== 'undefined') {\n    // only `maximum` is defined\n    return Math.min(value, maximum)\n  }\n  // both `minimum` and `maximum` are `undefined`\n  return value\n}\n\nfunction evaluateValue(value: string, suffix?: string): null | number {\n  if (value === MIXED_STRING) {\n    return MIXED_NUMBER\n  }\n  if (value === EMPTY_STRING) {\n    return null\n  }\n  return evaluateNumericExpression(trimSuffix(value, suffix))\n}\n\nfunction evaluateValueWithDelta(value: number, delta: number): number {\n  return parseFloat((value + delta).toFixed(FRACTION_DIGITS))\n}\n\nfunction trimSuffix(string: string, suffix?: string): string {\n  if (typeof suffix === 'undefined') {\n    return string\n  }\n  return string.replace(new RegExp(`${suffix}$`), EMPTY_STRING)\n}\n"],"names":["floatOperandRegex","integerOperandRegex","operatorRegex","operatorSuffixRegex","numbersRegex","invalidCharactersRegex","evaluateNumericExpression","value","test","eval","substring","length","parseFloat","isValidNumericInput","options","integersOnly","split","i","operand","EMPTY_STRING","fractionalPartRegex","nonDigitRegex","formatEvaluatedValue","evaluatedValue","suffix","significantFiguresCount","countSignificantFigures","appendSuffix","formatSignificantFigures","result","exec","repeat","fractionalPart","count","string","FRACTION_DIGITS","RawTextboxNumeric","createComponent","disabled","incrementBig","incrementSmall","integer","maximum","minimum","onBlur","noop","onFocus","onInput","onMouseDown","onKeyDown","onNumericValueInput","onValueInput","placeholder","propagateEscapeKeyDown","revertOnEscapeKeyDown","validateOnBlur","rest","ref","Error","inputElementRef","useRef","revertOnEscapeKeyDownRef","originalValue","setOriginalValue","useState","setInputElementValue","useCallback","inputElement","getCurrentFromRef","inputEvent","window","Event","bubbles","cancelable","dispatchEvent","handleBlur","event","current","evaluateValue","MIXED_STRING","formattedValue","handleFocus","currentTarget","select","handleInput","newValue","handleKeyDown","key","stopPropagation","blur","delta","shiftKey","preventDefault","startingValue","evaluateValueWithDelta","restrictValue","number","ctrlKey","metaKey","isKeyCodeCharacterGenerating","keyCode","trimSuffix","computeNextValue","handleMouseDown","handlePaste","clipboardData","nextValue","getData","refCallback","_jsx","onPaste","spellcheck","tabIndex","type","Math","min","max","MIXED_NUMBER","toFixed","replace","RegExp"],"mappings":"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"}