{"version":3,"file":"textbox-autocomplete-40a3642f.js","sources":["../../src/components/textbox/textbox-autocomplete/textbox-autocomplete.tsx"],"sourcesContent":["import { ComponentChildren, h, RefObject } from 'preact'\nimport { useCallback, useEffect, useRef, useState } from 'preact/hooks'\n\nimport menuStyles from '../../../css/menu.module.css'\nimport { useMouseDownOutside } from '../../../hooks/use-mouse-down-outside.js'\nimport { IconMenuCheckmarkChecked16 } from '../../../icons/icon-16/icon-menu-checkmark-checked-16.js'\nimport { Event, EventHandler } from '../../../types/event-handler.js'\nimport { createClassName } from '../../../utilities/create-class-name.js'\nimport { createComponent } from '../../../utilities/create-component.js'\nimport { getCurrentFromRef } from '../../../utilities/get-current-from-ref.js'\nimport { noop } from '../../../utilities/no-op.js'\nimport {\n  INVALID_ID,\n  ITEM_ID_DATA_ATTRIBUTE_NAME,\n  VIEWPORT_MARGIN\n} from '../../../utilities/private/constants.js'\nimport { computeNextValue } from '../private/compute-next-value.js'\nimport { isKeyCodeCharacterGenerating } from '../private/is-keycode-character-generating.js'\nimport textboxStyles from '../textbox/textbox.module.css'\nimport textboxAutocompleteStyles from './textbox-autocomplete.module.css'\n\nconst EMPTY_STRING = ''\n\nexport interface TextboxAutocompleteProps {\n  disabled?: boolean\n  filter?: boolean\n  icon?: ComponentChildren\n  onChange?: EventHandler.onChange<HTMLInputElement>\n  onInput?: EventHandler.onInput<HTMLInputElement>\n  onKeyDown?: EventHandler.onKeyDown<HTMLInputElement>\n  onMouseDown?: EventHandler.onMouseDown<HTMLInputElement>\n  onPaste?: EventHandler.onPaste<HTMLInputElement>\n  onValueInput?: EventHandler.onValueChange<string>\n  options: Array<TextboxAutocompleteOption>\n  placeholder?: string\n  propagateEscapeKeyDown?: boolean\n  revertOnEscapeKeyDown?: boolean\n  spellCheck?: boolean\n  strict?: boolean\n  top?: boolean\n  value: string\n  variant?: TextboxAutocompleteVariant\n}\nexport type TextboxAutocompleteOption =\n  | TextboxAutocompleteOptionHeader\n  | TextboxAutocompleteOptionValue\n  | TextboxAutocompleteOptionSeparator\nexport type TextboxAutocompleteOptionHeader = {\n  header: string\n}\nexport type TextboxAutocompleteOptionValue = {\n  value: string\n  disabled?: boolean\n}\nexport type TextboxAutocompleteOptionSeparator = '-'\nexport type TextboxAutocompleteVariant = 'border' | 'underline'\n\ntype Option =\n  | TextboxAutocompleteOptionHeader\n  | OptionValueWithId\n  | TextboxAutocompleteOptionSeparator\ntype OptionValueWithId = TextboxAutocompleteOptionValue & {\n  id: string\n}\ntype Id = typeof INVALID_ID | string\n\nexport const TextboxAutocomplete = createComponent<\n  HTMLInputElement,\n  TextboxAutocompleteProps\n>(function (\n  {\n    disabled = false,\n    filter = false,\n    icon,\n    onChange = noop,\n    onInput = noop,\n    onKeyDown = noop,\n    onMouseDown = noop,\n    onPaste = noop,\n    onValueInput = noop,\n    placeholder,\n    propagateEscapeKeyDown = true,\n    revertOnEscapeKeyDown = false,\n    spellCheck = false,\n    strict = false,\n    top = false,\n    value,\n    variant,\n    ...rest\n  },\n  ref\n) {\n  if (typeof icon === 'string' && icon.length !== 1) {\n    throw new Error(`String \\`icon\\` must be a single character: ${icon}`)\n  }\n\n  const rootElementRef: RefObject<HTMLDivElement> = useRef(null)\n  const inputElementRef: RefObject<HTMLInputElement> = useRef(null)\n  const menuElementRef: RefObject<HTMLDivElement> = useRef(null)\n\n  const revertOnEscapeKeyDownRef: RefObject<boolean> = useRef(false) // Set to `true` when the `Escape` key is pressed; used to bail out of `handleTextboxInput`\n\n  const [originalValue, setOriginalValue] = useState<string>(value) // Value of the textbox when the menu is focused\n  const [editedValue, setEditedValue] = useState<string>(EMPTY_STRING) // Value being edited that does not match any of the options\n  const [isMenuVisible, setIsMenuVisible] = useState<boolean>(false)\n  const [selectedId, setSelectedId] = useState<Id>(INVALID_ID)\n\n  const options =\n    filter === true\n      ? filterOptions(createOptions(rest.options), value, editedValue)\n      : createOptions(rest.options)\n\n  // Uncomment to debug\n  // console.table([\n  //   { editedValue, isMenuVisible, originalValue, selectedId, value }\n  // ])\n\n  const triggerTextboxSelect = useCallback(function () {\n    getCurrentFromRef(inputElementRef).select()\n  }, [])\n\n  const triggerTextboxBlur = useCallback(function () {\n    getCurrentFromRef(inputElementRef).blur()\n  }, [])\n\n  const triggerMenuUpdateScrollPosition = useCallback(function (id: Id) {\n    // Adjust the menu scroll position so that the selected option is always visible\n    const menuElement = getCurrentFromRef(menuElementRef)\n    if (id === INVALID_ID) {\n      menuElement.scrollTop = 0\n      return\n    }\n    const selectedElement = menuElement.querySelector<HTMLDivElement>(\n      `[${ITEM_ID_DATA_ATTRIBUTE_NAME}='${id}']`\n    )\n    if (selectedElement === null) {\n      throw new Error('`selectedElement` is `null`')\n    }\n    const y =\n      selectedElement.getBoundingClientRect().y -\n      menuElement.getBoundingClientRect().y\n    if (y < menuElement.scrollTop) {\n      menuElement.scrollTop = y\n      return\n    }\n    const offsetBottom = y + selectedElement.offsetHeight\n    if (offsetBottom > menuElement.scrollTop + menuElement.offsetHeight) {\n      menuElement.scrollTop = offsetBottom - menuElement.offsetHeight\n    }\n  }, [])\n\n  const updateSelectedId = useCallback(\n    function (value: string) {\n      const id = getIdByValue(options, value)\n      if (id === INVALID_ID) {\n        setEditedValue(value) // Copy `value` to `editedValue`\n      }\n      setSelectedId(id)\n      triggerMenuUpdateScrollPosition(id)\n    },\n    [options, triggerMenuUpdateScrollPosition]\n  )\n\n  const updateTextboxValue = useCallback(function (value: string) {\n    const inputElement = getCurrentFromRef(inputElementRef)\n    inputElement.value = value\n    const inputEvent = new window.Event('input', {\n      bubbles: true,\n      cancelable: true\n    })\n    inputElement.dispatchEvent(inputEvent)\n  }, [])\n\n  const triggerMenuHide = useCallback(function () {\n    setIsMenuVisible(false)\n  }, [])\n\n  const triggerMenuShow = useCallback(\n    function () {\n      updateMenuElementMaxHeight(\n        getCurrentFromRef(rootElementRef),\n        getCurrentFromRef(menuElementRef),\n        top\n      )\n      setOriginalValue(value)\n      updateSelectedId(value)\n      setIsMenuVisible(true)\n    },\n    [top, updateSelectedId, value]\n  )\n\n  const handleTextboxInput = useCallback(\n    function (event: Event.onInput<HTMLInputElement>) {\n      onInput(event)\n      const newValue = event.currentTarget.value\n      updateSelectedId(newValue)\n      onValueInput(newValue)\n      if (isMenuVisible === true) {\n        return\n      }\n      if (revertOnEscapeKeyDownRef.current === true) {\n        revertOnEscapeKeyDownRef.current = false\n        return\n      }\n      triggerMenuShow()\n    },\n    [isMenuVisible, onInput, onValueInput, triggerMenuShow, updateSelectedId]\n  )\n\n  const handleTextboxKeyDown = useCallback(\n    function (event: Event.onKeyDown<HTMLInputElement>) {\n      onKeyDown(event)\n      const inputElement = event.currentTarget\n      const key = event.key\n      if (key === 'ArrowUp' || key === 'ArrowDown') {\n        event.preventDefault()\n        if (isMenuVisible === false) {\n          triggerMenuShow()\n          return\n        }\n        if (options.length === 0) {\n          return\n        }\n        const id =\n          key === 'ArrowUp'\n            ? computePreviousId(options, selectedId)\n            : computeNextId(options, selectedId)\n        if (id === INVALID_ID) {\n          // Reached beginning/end of list of `options`, so just restore `editedValue`\n          setSelectedId(INVALID_ID)\n          updateTextboxValue(editedValue)\n          triggerTextboxSelect()\n          triggerMenuUpdateScrollPosition(INVALID_ID)\n          return\n        }\n        // Set the selected option to `id`\n        setSelectedId(id)\n        const optionValue = findOptionValueById(options, id)\n        if (optionValue === null) {\n          throw new Error('`optionValue` is `null`')\n        }\n        // Imperatively set the textbox value\n        updateTextboxValue(optionValue.value)\n        triggerTextboxSelect()\n        triggerMenuUpdateScrollPosition(id)\n        return\n      }\n      if (key === 'Escape') {\n        event.preventDefault()\n        if (propagateEscapeKeyDown === false) {\n          event.stopPropagation()\n        }\n        if (revertOnEscapeKeyDown === true) {\n          revertOnEscapeKeyDownRef.current = true\n          updateTextboxValue(originalValue)\n        }\n        // Hide the menu if it is visible, else blur the textbox\n        if (isMenuVisible === true) {\n          triggerMenuHide()\n          return\n        }\n        triggerTextboxBlur()\n        return\n      }\n      if (key === 'Enter') {\n        event.preventDefault()\n        triggerTextboxSelect()\n        // Toggle visibility of the menu\n        if (isMenuVisible === true) {\n          triggerMenuHide()\n          return\n        }\n        triggerMenuShow()\n        return\n      }\n      if (key === 'Tab') {\n        triggerMenuHide()\n        return\n      }\n      if (strict === false) {\n        return\n      }\n      if (event.ctrlKey === true || event.metaKey === true) {\n        return\n      }\n      if (isKeyCodeCharacterGenerating(event.keyCode) === true) {\n        // Piece together `newValue`, and stop the `keyDown` event if `newValue` is invalid\n        const nextValue = computeNextValue(inputElement, event.key)\n        if (isValidValue(options, nextValue) === true) {\n          return\n        }\n        event.preventDefault()\n      }\n    },\n    [\n      editedValue,\n      isMenuVisible,\n      onKeyDown,\n      options,\n      originalValue,\n      propagateEscapeKeyDown,\n      revertOnEscapeKeyDown,\n      selectedId,\n      strict,\n      triggerMenuHide,\n      triggerMenuShow,\n      triggerMenuUpdateScrollPosition,\n      triggerTextboxBlur,\n      triggerTextboxSelect,\n      updateTextboxValue\n    ]\n  )\n\n  const handleTextboxMouseDown = useCallback(\n    function (event: Event.onMouseDown<HTMLInputElement>) {\n      onMouseDown(event)\n      if (isMenuVisible === true) {\n        return\n      }\n      event.preventDefault()\n      triggerTextboxSelect()\n      triggerMenuShow()\n    },\n    [isMenuVisible, onMouseDown, triggerTextboxSelect, triggerMenuShow]\n  )\n\n  const handleTextboxPaste = useCallback(\n    function (event: Event.onPaste<HTMLInputElement>) {\n      onPaste(event)\n      // Piece together the `nextValue`, and stop the `paste` event (by\n      // calling `event.preventDefault()`) if `nextValue` is found to\n      // be invalid\n      if (strict === false) {\n        return\n      }\n      if (event.clipboardData === null) {\n        throw new Error('`event.clipboardData` is `null`')\n      }\n      const nextValue = computeNextValue(\n        event.currentTarget,\n        event.clipboardData.getData('Text')\n      )\n      if (isValidValue(options, nextValue) === true) {\n        return\n      }\n      event.preventDefault()\n    },\n    [onPaste, options, strict]\n  )\n\n  const handleOptionChange = useCallback(\n    function (event: Event.onChange<HTMLInputElement>) {\n      onChange(event)\n      const id = event.currentTarget.getAttribute(ITEM_ID_DATA_ATTRIBUTE_NAME)\n      if (id === null) {\n        throw new Error('`id` is `null`')\n      }\n      // Set the selected option to `id`\n      setSelectedId(id)\n      const optionValue = findOptionValueById(options, id)\n      if (optionValue === null) {\n        throw new Error('`optionValue` is `null`')\n      }\n      // Imperatively set the textbox value; the new value will eventually\n      // reach `handleTextboxInput`\n      updateTextboxValue(optionValue.value)\n      // Select the textbox, then hide the menu\n      triggerTextboxSelect()\n      triggerMenuHide()\n    },\n    [\n      onChange,\n      options,\n      triggerMenuHide,\n      triggerTextboxSelect,\n      updateTextboxValue\n    ]\n  )\n\n  const handleOptionMouseMove = useCallback(\n    function (event: Event.onMouseMove<HTMLInputElement>) {\n      // Set the selected option to the one being moused over\n      const id = event.currentTarget.getAttribute(ITEM_ID_DATA_ATTRIBUTE_NAME)\n      if (id === null) {\n        throw new Error('`id` is `null`')\n      }\n      if (id === selectedId) {\n        return\n      }\n      setSelectedId(id)\n    },\n    [selectedId]\n  )\n\n  const handleMouseDownOutside = useCallback(\n    function () {\n      if (isMenuVisible === false) {\n        return\n      }\n      triggerMenuHide()\n      triggerTextboxBlur()\n    },\n    [isMenuVisible, triggerTextboxBlur, triggerMenuHide]\n  )\n  useMouseDownOutside({\n    onMouseDownOutside: handleMouseDownOutside,\n    ref: rootElementRef\n  })\n\n  useEffect(\n    function () {\n      function handleWindowScroll() {\n        if (isMenuVisible === false) {\n          return\n        }\n        triggerMenuHide()\n        triggerTextboxSelect()\n      }\n      window.addEventListener('scroll', handleWindowScroll)\n      return function () {\n        window.removeEventListener('scroll', handleWindowScroll)\n      }\n    },\n    [isMenuVisible, triggerMenuHide, triggerTextboxSelect]\n  )\n\n  const refCallback = useCallback(\n    function (inputElement: null | HTMLInputElement) {\n      inputElementRef.current = inputElement\n      if (ref === null) {\n        return\n      }\n      if (typeof ref === 'function') {\n        ref(inputElement)\n        return\n      }\n      ref.current = inputElement\n    },\n    [ref]\n  )\n\n  return (\n    <div\n      ref={rootElementRef}\n      class={createClassName([\n        textboxStyles.textbox,\n        typeof variant === 'undefined'\n          ? null\n          : variant === 'border'\n          ? textboxStyles.hasBorder\n          : null,\n        typeof icon === 'undefined' ? null : textboxStyles.hasIcon,\n        disabled === true ? textboxStyles.disabled : null\n      ])}\n    >\n      <div class={textboxStyles.inner}>\n        <input\n          {...rest}\n          ref={refCallback}\n          class={textboxStyles.input}\n          disabled={disabled === true}\n          onInput={handleTextboxInput}\n          onKeyDown={handleTextboxKeyDown}\n          onMouseDown={handleTextboxMouseDown}\n          onPaste={handleTextboxPaste}\n          placeholder={placeholder}\n          spellcheck={spellCheck}\n          tabIndex={0}\n          type=\"text\"\n          value={value}\n        />\n        {typeof icon === 'undefined' ? null : (\n          <div class={textboxStyles.icon}>{icon}</div>\n        )}\n        <div class={textboxStyles.border} />\n        {variant === 'underline' ? (\n          <div class={textboxStyles.underline} />\n        ) : null}\n        <div\n          ref={menuElementRef}\n          class={createClassName([\n            menuStyles.menu,\n            disabled === true || isMenuVisible === false\n              ? menuStyles.hidden\n              : null,\n            top === true\n              ? textboxAutocompleteStyles.top\n              : textboxAutocompleteStyles.bottom\n          ])}\n        >\n          {options.map(function (option: Option, index: number) {\n            if (typeof option === 'string') {\n              return <hr key={index} class={menuStyles.optionSeparator} />\n            }\n            if ('header' in option) {\n              return (\n                <h1 key={index} class={menuStyles.optionHeader}>\n                  {option.header}\n                </h1>\n              )\n            }\n            return (\n              <label\n                key={index}\n                class={createClassName([\n                  menuStyles.optionValue,\n                  option.disabled === true\n                    ? menuStyles.optionValueDisabled\n                    : null,\n                  option.disabled !== true && option.id === selectedId\n                    ? menuStyles.optionValueSelected\n                    : null\n                ])}\n              >\n                <input\n                  checked={value === option.value}\n                  class={menuStyles.input}\n                  disabled={option.disabled === true}\n                  // If clicked on an unselected element, set the value\n                  onChange={\n                    value === option.value ? undefined : handleOptionChange\n                  }\n                  // Else hide the menu if clicked on an already-selected element\n                  onClick={value === option.value ? triggerMenuHide : undefined}\n                  onMouseMove={handleOptionMouseMove}\n                  tabIndex={-1}\n                  type=\"radio\"\n                  value={`${option.value}`}\n                  {...{ [ITEM_ID_DATA_ATTRIBUTE_NAME]: option.id }}\n                />\n                {option.value === originalValue ? ( // Show check icon if option matches `originalValue`\n                  <div class={menuStyles.checkIcon}>\n                    <IconMenuCheckmarkChecked16 />\n                  </div>\n                ) : null}\n                {option.value}\n              </label>\n            )\n          })}\n        </div>\n      </div>\n    </div>\n  )\n})\n\n// Add an `id` attribute to all the `TextboxAutocompleteOptionValue` items in `options`\nfunction createOptions(\n  options: Array<TextboxAutocompleteOption>\n): Array<Option> {\n  return options.map(function (\n    option: TextboxAutocompleteOption,\n    index: number\n  ): Option {\n    if (typeof option !== 'string' && 'value' in option) {\n      const optionValueWithId: OptionValueWithId = {\n        ...option,\n        id: `${index}`\n      }\n      return optionValueWithId\n    }\n    return option\n  })\n}\n\nfunction filterOptions(\n  options: Array<Option>,\n  value: string,\n  editedValue: string\n): Array<Option> {\n  if (value === EMPTY_STRING) {\n    return options\n  }\n  const id = getIdByValue(options, value)\n  if (id === INVALID_ID) {\n    // `value` does not match any option in `options`\n    return options.filter(function (option: Option): boolean {\n      if (typeof option !== 'string' && 'value' in option) {\n        return doesStringContainSubstring(option.value, value) === true\n      }\n      return false\n    })\n  }\n  // `value` matches one of the options in `options`\n  if (editedValue === EMPTY_STRING) {\n    return options\n  }\n  // Filter `options` by `editedValue`\n  return options.filter(function (option: Option): boolean {\n    if (typeof option !== 'string' && 'value' in option) {\n      return doesStringContainSubstring(option.value, editedValue) === true\n    }\n    return false\n  })\n}\n\n// Returns `true` if `string` contains `substring`, else `false`\nfunction doesStringContainSubstring(\n  string: string,\n  substring: string\n): boolean {\n  return string.toLowerCase().indexOf(substring.toLowerCase()) !== -1\n}\n\n// Returns the `id` of an `OptionValueWithId` in `options` with the given `value`\nfunction getIdByValue(options: Array<Option>, value: string): Id {\n  for (const option of options) {\n    if (typeof option !== 'string' && 'value' in option) {\n      if (option.value === value) {\n        return option.id\n      }\n    }\n  }\n  return INVALID_ID\n}\n\n// Returns `true` if `value` is a substring of `options[i].value` in `options`, else `false`\nfunction isValidValue(options: Array<Option>, value: string): boolean {\n  if (value === EMPTY_STRING) {\n    return true\n  }\n  for (const option of options) {\n    if (typeof option !== 'string' && 'value' in option) {\n      if (option.value.toLowerCase().indexOf(value.toLowerCase()) === 0) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\n// Returns the `OptionValueWithId` in `options` with the given `id`, else `null`\nfunction findOptionValueById(\n  options: Array<Option>,\n  id: string\n): null | OptionValueWithId {\n  for (const option of options) {\n    if (typeof option !== 'string' && 'id' in option && option.id === id) {\n      return option\n    }\n  }\n  return null\n}\n\n// Returns the index of the `OptionValueWithId` in `options` with the given `id`, else `-1`\nfunction getIndexById(options: Array<Option>, id: string): number {\n  let index = 0\n  for (const option of options) {\n    if (typeof option !== 'string' && 'id' in option && option.id === id) {\n      return index\n    }\n    index += 1\n  }\n  return -1\n}\n\n// Returns the `Id` of the `OptionValueWithId` _before_ the `OptionValueWithId` in `options` with the given `id`\nfunction computePreviousId(options: Array<Option>, id: Id): Id {\n  if (id === INVALID_ID) {\n    const result = findOptionValueAtOrBeforeIndex(options, options.length - 1)\n    return result === null ? null : result.id\n  }\n  const index = getIndexById(options, id)\n  if (index === -1) {\n    throw new Error(`No option with \\`id\\` ${id}`)\n  }\n  if (index === 0) {\n    return null\n  }\n  const result = findOptionValueAtOrBeforeIndex(options, index - 1)\n  return result === null ? null : result.id\n}\n\n// Returns the `Id` of the `OptionValueWithId` _after_ the `OptionValueWithId` in `options` with the given `id`\nfunction computeNextId(options: Array<Option>, id: Id): Id {\n  if (id === INVALID_ID) {\n    const result = findOptionValueAtOrAfterIndex(options, 0)\n    return result === null ? null : result.id\n  }\n  const index = getIndexById(options, id)\n  if (index === -1) {\n    throw new Error(`No option with \\`id\\` ${id}`)\n  }\n  if (index === options.length - 1) {\n    return null\n  }\n  const result = findOptionValueAtOrAfterIndex(options, index + 1)\n  return result === null ? null : result.id\n}\n\n// Returns the `OptionValueWithId` in `options` at or _before_ the `index`, else `null`\nfunction findOptionValueAtOrBeforeIndex(\n  options: Array<Option>,\n  index: number\n): null | OptionValueWithId {\n  if (index < 0) {\n    throw new Error('`index` < 0')\n  }\n  if (index > options.length - 1) {\n    throw new Error('`index` > `options.length` - 1')\n  }\n  return findLastOptionValue(options.slice(0, index + 1))\n}\n\n// Returns the `OptionValueWithId` in `options` at or _after_ the `index`, else `null`\nfunction findOptionValueAtOrAfterIndex(\n  options: Array<Option>,\n  index: number\n): null | OptionValueWithId {\n  if (index < 0) {\n    throw new Error('`index` < 0')\n  }\n  if (index > options.length - 1) {\n    throw new Error('`index` > `options.length` - 1')\n  }\n  return findFirstOptionValue(options.slice(index))\n}\n\n// Returns the first `OptionValueWithId` encountered in `options`, else `null`\nfunction findFirstOptionValue(\n  options: Array<Option>\n): null | OptionValueWithId {\n  for (const option of options) {\n    if (\n      typeof option !== 'string' &&\n      'id' in option &&\n      option.disabled !== true\n    ) {\n      return option\n    }\n  }\n  return null\n}\n\n// Returns the last `OptionValueWithId` encountered in `options`, else `null`\nfunction findLastOptionValue(options: Array<Option>): null | OptionValueWithId {\n  return findFirstOptionValue(options.slice().reverse())\n}\n\nfunction updateMenuElementMaxHeight(\n  rootElement: HTMLDivElement,\n  menuElement: HTMLDivElement,\n  top: boolean\n) {\n  const rootElementTop = rootElement.getBoundingClientRect().top\n  const maxHeight =\n    top === true\n      ? rootElementTop - VIEWPORT_MARGIN\n      : window.innerHeight -\n        rootElementTop -\n        rootElement.offsetHeight -\n        VIEWPORT_MARGIN\n  menuElement.style.maxHeight = `${maxHeight}px`\n}\n"],"names":["EMPTY_STRING","TextboxAutocomplete","createComponent","disabled","filter","icon","onChange","noop","onInput","onKeyDown","onMouseDown","onPaste","onValueInput","placeholder","propagateEscapeKeyDown","revertOnEscapeKeyDown","spellCheck","strict","top","value","variant","rest","ref","length","Error","rootElementRef","useRef","inputElementRef","menuElementRef","revertOnEscapeKeyDownRef","originalValue","setOriginalValue","useState","editedValue","setEditedValue","isMenuVisible","setIsMenuVisible","selectedId","setSelectedId","INVALID_ID","options","filterOptions","createOptions","triggerTextboxSelect","useCallback","select","triggerTextboxBlur","blur","triggerMenuUpdateScrollPosition","id","menuElement","getCurrentFromRef","scrollTop","selectedElement","querySelector","ITEM_ID_DATA_ATTRIBUTE_NAME","y","getBoundingClientRect","offsetBottom","offsetHeight","updateSelectedId","getIdByValue","updateTextboxValue","inputElement","inputEvent","window","Event","bubbles","cancelable","dispatchEvent","triggerMenuHide","triggerMenuShow","updateMenuElementMaxHeight","handleTextboxInput","event","newValue","currentTarget","current","handleTextboxKeyDown","key","preventDefault","computePreviousId","computeNextId","optionValue","findOptionValueById","stopPropagation","ctrlKey","metaKey","isKeyCodeCharacterGenerating","keyCode","nextValue","computeNextValue","isValidValue","handleTextboxMouseDown","handleTextboxPaste","clipboardData","getData","handleOptionChange","getAttribute","handleOptionMouseMove","handleMouseDownOutside","useMouseDownOutside","onMouseDownOutside","useEffect","handleWindowScroll","addEventListener","removeEventListener","refCallback","_jsx","class","createClassName","textboxStyles","textbox","hasBorder","hasIcon","children","_jsxs","inner","input","spellcheck","tabIndex","type","border","underline","menuStyles","menu","hidden","textboxAutocompleteStyles","bottom","map","option","index","optionSeparator","optionHeader","header","optionValueDisabled","optionValueSelected","checked","undefined","onClick","onMouseMove","checkIcon","IconMenuCheckmarkChecked16","doesStringContainSubstring","string","substring","toLowerCase","indexOf","getIndexById","result","findOptionValueAtOrBeforeIndex","findOptionValueAtOrAfterIndex","findLastOptionValue","slice","findFirstOptionValue","reverse","rootElement","rootElementTop","maxHeight","VIEWPORT_MARGIN","innerHeight","style"],"mappings":"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"}