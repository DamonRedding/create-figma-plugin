{"version":3,"file":"textbox-autocomplete-7a36de7c.js","sources":["../../src/components/textbox/textbox-autocomplete/textbox-autocomplete.tsx"],"sourcesContent":["import { ComponentChildren, h, JSX, RefObject } from 'preact'\nimport { useCallback, useRef, useState } from 'preact/hooks'\n\nimport menuStyles from '../../../css/menu.module.css'\nimport { useMouseDownOutside } from '../../../hooks/use-mouse-down-outside.js'\nimport { IconMenuCheckmarkChecked16 } from '../../../icons/icon-16/icon-menu-checkmark-checked-16.js'\nimport { OnValueChange, Props } from '../../../types/types.js'\nimport { createClassName } from '../../../utilities/create-class-name.js'\nimport { getCurrentFromRef } from '../../../utilities/get-current-from-ref.js'\nimport { computeNextValue } from '../private/compute-next-value.js'\nimport { isKeyCodeCharacterGenerating } from '../private/is-keycode-character-generating.js'\nimport textboxStyles from '../textbox/textbox.module.css'\nimport textboxAutocompleteStyles from './textbox-autocomplete.module.css'\n\nconst EMPTY_STRING = ''\nconst INVALID_ID = null\nconst ITEM_ID_DATA_ATTRIBUTE_NAME = 'data-textbox-autocomplete-item-id'\nconst MENU_VERTICAL_MARGIN = 16\n\nexport type TextboxAutocompleteProps<Name extends string> = {\n  disabled?: boolean\n  filter?: boolean\n  icon?: ComponentChildren\n  name?: Name\n  onInput?: OmitThisParameter<JSX.GenericEventHandler<HTMLInputElement>>\n  onValueInput?: OnValueChange<string, Name>\n  options: Array<TextboxAutocompleteOption>\n  placeholder?: string\n  propagateEscapeKeyDown?: boolean\n  revertOnEscapeKeyDown?: boolean\n  spellCheck?: boolean\n  strict?: boolean\n  top?: boolean\n  value: string\n  variant?: TextboxAutocompleteVariant\n}\nexport type TextboxAutocompleteOption =\n  | TextboxAutocompleteOptionHeader\n  | TextboxAutocompleteOptionValue\n  | TextboxAutocompleteOptionSeparator\nexport type TextboxAutocompleteOptionHeader = {\n  header: string\n}\nexport type TextboxAutocompleteOptionValue = {\n  value: string\n  disabled?: boolean\n}\nexport type TextboxAutocompleteOptionSeparator = {\n  separator: true\n}\nexport type TextboxAutocompleteVariant = 'border' | 'underline'\n\ntype Option =\n  | TextboxAutocompleteOptionHeader\n  | OptionValueWithId\n  | TextboxAutocompleteOptionSeparator\ntype OptionValueWithId = TextboxAutocompleteOptionValue & {\n  id: string\n}\ntype Id = typeof INVALID_ID | string\n\nexport function TextboxAutocomplete<Name extends string>({\n  disabled = false,\n  filter = false,\n  icon,\n  name,\n  onInput = function () {},\n  onValueInput = function () {},\n  placeholder,\n  propagateEscapeKeyDown = true,\n  revertOnEscapeKeyDown = false,\n  spellCheck = false,\n  strict = false,\n  top = false,\n  value,\n  variant,\n  ...rest\n}: Props<HTMLInputElement, TextboxAutocompleteProps<Name>>): JSX.Element {\n  if (typeof icon === 'string' && icon.length !== 1) {\n    throw new Error(`String \\`icon\\` must be a single character: ${icon}`)\n  }\n\n  const rootElementRef: RefObject<HTMLDivElement> = useRef(null)\n  const inputElementRef: RefObject<HTMLInputElement> = useRef(null)\n  const menuElementRef: RefObject<HTMLDivElement> = useRef(null)\n\n  const [isMenuVisible, setIsMenuVisible] = useState(false)\n  const [selectedId, setSelectedId] = useState<Id>(INVALID_ID)\n  const [originalValue, setOriginalValue] = useState(EMPTY_STRING) // Value of the textbox when it was initially focused\n  const [editedValue, setEditedValue] = useState<string>(value) // Value being edited that does not match any of the options\n\n  let options: Array<Option> = createOptions(rest.options)\n  if (filter === true) {\n    options = filterOptions(options, value, editedValue)\n  }\n\n  // Uncomment to debug\n  // console.table([{ isMenuVisible, selectedId, originalValue, editedValue, value }])\n\n  const triggerBlur = useCallback(function (): void {\n    setIsMenuVisible(false)\n    setOriginalValue(EMPTY_STRING)\n    setEditedValue(EMPTY_STRING)\n    setSelectedId(INVALID_ID)\n    getCurrentFromRef(inputElementRef).blur()\n  }, [])\n\n  // Adjust the menu scroll position so that the selected option is always visible\n  const updateScrollPosition = useCallback(function (id: Id): void {\n    const menuElement = getCurrentFromRef(menuElementRef)\n    if (id === INVALID_ID) {\n      menuElement.scrollTop = 0\n      return\n    }\n    const selectedElement = menuElement.querySelector<HTMLDivElement>(\n      `[${ITEM_ID_DATA_ATTRIBUTE_NAME}='${id}']`\n    )\n    if (selectedElement === null) {\n      throw new Error('Invariant violation') // `id` is valid\n    }\n    const y =\n      selectedElement.getBoundingClientRect().y -\n      menuElement.getBoundingClientRect().y\n    if (y < menuElement.scrollTop) {\n      menuElement.scrollTop = y\n      return\n    }\n    const offsetBottom = y + selectedElement.offsetHeight\n    if (offsetBottom > menuElement.scrollTop + menuElement.offsetHeight) {\n      menuElement.scrollTop = offsetBottom - menuElement.offsetHeight\n    }\n  }, [])\n\n  const updateEditedValue = useCallback(\n    function (editedValue: string): void {\n      const newId = getIdByValue(options, editedValue)\n      if (newId === INVALID_ID) {\n        // `newValue` does not match any option in `options`\n        setEditedValue(editedValue)\n        setSelectedId(INVALID_ID)\n        updateScrollPosition(INVALID_ID)\n        return\n      }\n      // `newValue` matches one of the options in `options`\n      setEditedValue(EMPTY_STRING)\n      setSelectedId(newId)\n      updateScrollPosition(newId)\n    },\n    [options, updateScrollPosition]\n  )\n\n  const handleFocus = useCallback(\n    function (event: JSX.TargetedFocusEvent<HTMLInputElement>): void {\n      setIsMenuVisible(true)\n      updateMenuElementMaxHeight(\n        getCurrentFromRef(rootElementRef),\n        getCurrentFromRef(menuElementRef),\n        top\n      )\n      setOriginalValue(value)\n      updateEditedValue(value)\n      const inputElement = event.currentTarget\n      inputElement.focus()\n      inputElement.select()\n    },\n    [top, updateEditedValue, value]\n  )\n\n  const handleInput = useCallback(\n    function (event: JSX.TargetedEvent<HTMLInputElement>): void {\n      const newValue = event.currentTarget.value\n      updateEditedValue(newValue)\n      onValueInput(newValue, name)\n      onInput(event)\n    },\n    [name, onInput, onValueInput, updateEditedValue]\n  )\n\n  const handleKeyDown = useCallback(\n    function (event: JSX.TargetedKeyboardEvent<HTMLInputElement>): void {\n      const inputElement = event.currentTarget\n      const key = event.key\n      if (key === 'ArrowUp' || key === 'ArrowDown') {\n        event.preventDefault()\n        if (options.length === 0) {\n          return\n        }\n        const newId =\n          key === 'ArrowUp'\n            ? computePreviousId(options, selectedId)\n            : computeNextId(options, selectedId)\n        if (newId === INVALID_ID) {\n          // Reached beginning/end of list of `options`, so just restore `savedValue`\n          setSelectedId(INVALID_ID)\n          inputElement.value = editedValue\n          onValueInput(editedValue, name)\n          onInput(event)\n          updateScrollPosition(INVALID_ID)\n          return\n        }\n        // Set the selected option to `newId`, and update `value`\n        setSelectedId(newId)\n        updateScrollPosition(newId)\n        const newOptionValue = findOptionValueById(options, newId)\n        if (newOptionValue === null) {\n          throw new Error('Invariant violation') // `newId` is valid\n        }\n        const newValue = newOptionValue.value\n        inputElement.value = newValue\n        onValueInput(newValue, name)\n        onInput(event)\n        inputElement.select()\n        return\n      }\n      if (key === 'Enter' || key === 'Escape' || key === 'Tab') {\n        event.preventDefault()\n        if (propagateEscapeKeyDown === false) {\n          event.stopPropagation()\n        }\n        if (key === 'Escape' && revertOnEscapeKeyDown === true) {\n          inputElement.value = originalValue\n          const inputEvent = document.createEvent('Event')\n          inputEvent.initEvent('input', true, true)\n          inputElement.dispatchEvent(inputEvent)\n        }\n        triggerBlur()\n        return\n      }\n      if (strict === false) {\n        return\n      }\n      if (event.ctrlKey === true || event.metaKey === true) {\n        return\n      }\n      if (isKeyCodeCharacterGenerating(event.keyCode) === true) {\n        // Piece together `newValue`, and stop the `keyDown` event if `newValue` is invalid\n        const newValue = computeNextValue(inputElement, event.key)\n        if (isValidValue(options, newValue) === false) {\n          event.preventDefault()\n        }\n      }\n    },\n    [\n      editedValue,\n      name,\n      onInput,\n      onValueInput,\n      options,\n      originalValue,\n      propagateEscapeKeyDown,\n      revertOnEscapeKeyDown,\n      selectedId,\n      strict,\n      triggerBlur,\n      updateScrollPosition\n    ]\n  )\n\n  const handlePaste = useCallback(\n    function (event: JSX.TargetedClipboardEvent<HTMLInputElement>): void {\n      if (strict === false) {\n        return\n      }\n      if (event.clipboardData === null) {\n        throw new Error('`event.clipboardData` is `null`')\n      }\n      const newValue = computeNextValue(\n        event.currentTarget,\n        event.clipboardData.getData('Text')\n      )\n      if (isValidValue(options, newValue) === false) {\n        event.preventDefault()\n      }\n    },\n    [options, strict]\n  )\n\n  const handleOptionChange = useCallback(\n    function (event: JSX.TargetedEvent<HTMLInputElement>): void {\n      const newId = event.currentTarget.getAttribute(\n        ITEM_ID_DATA_ATTRIBUTE_NAME\n      ) as string\n      // Set the selected option to `newId`, and update `value`\n      setSelectedId(newId)\n      const newOptionValue = findOptionValueById(options, newId)\n      if (newOptionValue === null) {\n        throw new Error('Invariant violation') // `newId` is valid\n      }\n      const inputElement = getCurrentFromRef(inputElementRef)\n      inputElement.value = newOptionValue.value\n      const inputEvent = document.createEvent('Event')\n      inputEvent.initEvent('input', true, true)\n      inputElement.dispatchEvent(inputEvent)\n      triggerBlur()\n    },\n    [options, triggerBlur]\n  )\n\n  const handleOptionMouseMove = useCallback(\n    function (event: JSX.TargetedMouseEvent<HTMLInputElement>): void {\n      const newId = event.currentTarget.getAttribute(\n        ITEM_ID_DATA_ATTRIBUTE_NAME\n      ) as string\n      if (newId !== selectedId) {\n        setSelectedId(newId)\n      }\n    },\n    [selectedId]\n  )\n\n  const handleMouseDownOutside = useCallback(\n    function (): void {\n      if (isMenuVisible === false) {\n        return\n      }\n      triggerBlur()\n    },\n    [isMenuVisible, triggerBlur]\n  )\n  useMouseDownOutside({\n    onMouseDownOutside: handleMouseDownOutside,\n    ref: rootElementRef\n  })\n\n  return (\n    <div\n      ref={rootElementRef}\n      class={createClassName([\n        textboxStyles.textbox,\n        typeof variant === 'undefined'\n          ? null\n          : variant === 'border'\n          ? textboxStyles.hasBorder\n          : null,\n        typeof icon === 'undefined' ? null : textboxStyles.hasIcon,\n        disabled === true ? textboxStyles.disabled : null\n      ])}\n    >\n      <div class={textboxStyles.inner}>\n        <input\n          {...rest}\n          ref={inputElementRef}\n          class={textboxStyles.input}\n          disabled={disabled === true}\n          name={name}\n          onFocus={handleFocus}\n          onInput={handleInput}\n          onKeyDown={handleKeyDown}\n          onPaste={handlePaste}\n          placeholder={placeholder}\n          tabIndex={disabled === true ? -1 : 0}\n          type=\"text\"\n          value={value}\n        />\n        {typeof icon === 'undefined' ? null : (\n          <div class={textboxStyles.icon}>{icon}</div>\n        )}\n        <div class={textboxStyles.border} />\n        {variant === 'underline' ? (\n          <div class={textboxStyles.underline} />\n        ) : null}\n        <div\n          ref={menuElementRef}\n          class={createClassName([\n            menuStyles.menu,\n            disabled === true || isMenuVisible === false\n              ? menuStyles.hidden\n              : null,\n            top === true\n              ? textboxAutocompleteStyles.top\n              : textboxAutocompleteStyles.bottom\n          ])}\n        >\n          {options.map(function (option: Option, index: number): JSX.Element {\n            if ('separator' in option) {\n              return <hr key={index} class={menuStyles.optionSeparator} />\n            }\n            if ('header' in option) {\n              return (\n                <h1 key={index} class={menuStyles.optionHeader}>\n                  {option.header}\n                </h1>\n              )\n            }\n            return (\n              <label\n                key={index}\n                class={createClassName([\n                  menuStyles.optionValue,\n                  option.disabled === true\n                    ? menuStyles.optionValueDisabled\n                    : null,\n                  option.disabled !== true && option.id === selectedId\n                    ? menuStyles.optionValueSelected\n                    : null\n                ])}\n              >\n                <input\n                  {...rest}\n                  checked={value === option.value}\n                  class={menuStyles.input}\n                  disabled={option.disabled === true}\n                  name={name}\n                  onChange={handleOptionChange}\n                  onMouseMove={handleOptionMouseMove}\n                  spellcheck={spellCheck}\n                  tabIndex={-1}\n                  type=\"radio\"\n                  value={`${option.value}`}\n                  {...{ [ITEM_ID_DATA_ATTRIBUTE_NAME]: option.id }}\n                />\n                {option.value === originalValue ? ( // Show check icon if option matches `originalValue`\n                  <div class={menuStyles.checkIcon}>\n                    <IconMenuCheckmarkChecked16 />\n                  </div>\n                ) : null}\n                {option.value}\n              </label>\n            )\n          })}\n        </div>\n      </div>\n    </div>\n  )\n}\n\n// Add an `id` attribute to all the `TextboxAutocompleteOptionValue` items in `options`\nfunction createOptions(\n  options: Array<TextboxAutocompleteOption>\n): Array<Option> {\n  return options.map(function (\n    option: TextboxAutocompleteOption,\n    index: number\n  ): Option {\n    if ('value' in option) {\n      const optionValueWithId: OptionValueWithId = {\n        ...option,\n        id: `${index}`\n      }\n      return optionValueWithId\n    }\n    return option\n  })\n}\n\nfunction filterOptions(\n  options: Array<Option>,\n  value: string,\n  editedValue: string\n): Array<Option> {\n  if (value === EMPTY_STRING) {\n    return options\n  }\n  const id = getIdByValue(options, value)\n  if (id === INVALID_ID) {\n    // `value` does not match any option in `options`\n    return options.filter(function (option: Option): boolean {\n      if ('value' in option) {\n        return doesStringContainSubstring(option.value, value) === true\n      }\n      return false\n    })\n  }\n  // `value` matches one of the options in `options`\n  if (editedValue === EMPTY_STRING) {\n    return options\n  }\n  // Filter `options` by `editedValue`\n  return options.filter(function (option: Option): boolean {\n    if ('value' in option) {\n      return doesStringContainSubstring(option.value, editedValue) === true\n    }\n    return false\n  })\n}\n\n// Returns `true` if `string` contains `substring`, else `false`\nfunction doesStringContainSubstring(\n  string: string,\n  substring: string\n): boolean {\n  return string.toLowerCase().indexOf(substring.toLowerCase()) !== -1\n}\n\n// Returns the `id` of an `OptionValueWithId` in `options` with the given `value`\nfunction getIdByValue(options: Array<Option>, value: string): Id {\n  for (const option of options) {\n    if ('value' in option) {\n      if (option.value === value) {\n        return option.id\n      }\n    }\n  }\n  return INVALID_ID\n}\n\n// Returns `true` if `value` is a substring of `options[i].value` in `options`, else `false`\nfunction isValidValue(options: Array<Option>, value: string): boolean {\n  if (value === EMPTY_STRING) {\n    return true\n  }\n  for (const option of options) {\n    if ('value' in option) {\n      if (option.value.toLowerCase().indexOf(value.toLowerCase()) === 0) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\n// Returns the `OptionValueWithId` in `options` with the given `id`, else `null`\nfunction findOptionValueById(\n  options: Array<Option>,\n  id: string\n): null | OptionValueWithId {\n  for (const option of options) {\n    if ('id' in option && option.id === id) {\n      return option\n    }\n  }\n  return null\n}\n\n// Returns the index of the `OptionValueWithId` in `options` with the given `id`, else `-1`\nfunction getIndexById(options: Array<Option>, id: string): number {\n  let index = 0\n  for (const option of options) {\n    if ('id' in option && option.id === id) {\n      return index\n    }\n    index += 1\n  }\n  return -1\n}\n\n// Returns the `Id` of the `OptionValueWithId` _before_ the `OptionValueWithId` in `options` with the given `id`\nfunction computePreviousId(options: Array<Option>, id: Id): Id {\n  if (id === INVALID_ID) {\n    const result = findOptionValueAtOrBeforeIndex(options, options.length - 1)\n    return result === null ? null : result.id\n  }\n  const index = getIndexById(options, id)\n  if (index === -1) {\n    throw new Error(`No option with \\`id\\` ${id}`)\n  }\n  if (index === 0) {\n    return null\n  }\n  const result = findOptionValueAtOrBeforeIndex(options, index - 1)\n  return result === null ? null : result.id\n}\n\n// Returns the `Id` of the `OptionValueWithId` _after_ the `OptionValueWithId` in `options` with the given `id`\nfunction computeNextId(options: Array<Option>, id: Id): Id {\n  if (id === INVALID_ID) {\n    const result = findOptionValueAtOrAfterIndex(options, 0)\n    return result === null ? null : result.id\n  }\n  const index = getIndexById(options, id)\n  if (index === -1) {\n    throw new Error(`No option with \\`id\\` ${id}`)\n  }\n  if (index === options.length - 1) {\n    return null\n  }\n  const result = findOptionValueAtOrAfterIndex(options, index + 1)\n  return result === null ? null : result.id\n}\n\n// Returns the `OptionValueWithId` in `options` at or _before_ the `index`, else `null`\nfunction findOptionValueAtOrBeforeIndex(\n  options: Array<Option>,\n  index: number\n): null | OptionValueWithId {\n  if (index < 0) {\n    throw new Error('`index` < 0')\n  }\n  if (index > options.length - 1) {\n    throw new Error('`index` > `options.length` - 1')\n  }\n  return findLastOptionValue(options.slice(0, index + 1))\n}\n\n// Returns the `OptionValueWithId` in `options` at or _after_ the `index`, else `null`\nfunction findOptionValueAtOrAfterIndex(\n  options: Array<Option>,\n  index: number\n): null | OptionValueWithId {\n  if (index < 0) {\n    throw new Error('`index` < 0')\n  }\n  if (index > options.length - 1) {\n    throw new Error('`index` > `options.length` - 1')\n  }\n  return findFirstOptionValue(options.slice(index))\n}\n\n// Returns the first `OptionValueWithId` encountered in `options`, else `null`\nfunction findFirstOptionValue(\n  options: Array<Option>\n): null | OptionValueWithId {\n  for (const option of options) {\n    if ('id' in option && option.disabled !== true) {\n      return option\n    }\n  }\n  return null\n}\n\n// Returns the last `OptionValueWithId` encountered in `options`, else `null`\nfunction findLastOptionValue(options: Array<Option>): null | OptionValueWithId {\n  return findFirstOptionValue(options.slice().reverse())\n}\n\nfunction updateMenuElementMaxHeight(\n  rootElement: HTMLDivElement,\n  menuElement: HTMLDivElement,\n  top: boolean\n) {\n  const rootElementTop = rootElement.getBoundingClientRect().top\n  const maxHeight =\n    top === true\n      ? rootElementTop - MENU_VERTICAL_MARGIN\n      : window.innerHeight -\n        rootElementTop -\n        rootElement.offsetHeight -\n        MENU_VERTICAL_MARGIN\n  menuElement.style.maxHeight = `${maxHeight}px`\n}\n"],"names":["EMPTY_STRING","INVALID_ID","ITEM_ID_DATA_ATTRIBUTE_NAME","MENU_VERTICAL_MARGIN","TextboxAutocomplete","disabled","filter","icon","name","onInput","onValueInput","placeholder","propagateEscapeKeyDown","revertOnEscapeKeyDown","spellCheck","strict","top","value","variant","rest","length","Error","rootElementRef","useRef","inputElementRef","menuElementRef","isMenuVisible","setIsMenuVisible","useState","selectedId","setSelectedId","originalValue","setOriginalValue","editedValue","setEditedValue","options","createOptions","filterOptions","triggerBlur","useCallback","blur","updateScrollPosition","id","menuElement","getCurrentFromRef","scrollTop","selectedElement","querySelector","y","getBoundingClientRect","offsetBottom","offsetHeight","updateEditedValue","newId","getIdByValue","handleFocus","event","updateMenuElementMaxHeight","inputElement","currentTarget","focus","select","handleInput","newValue","handleKeyDown","key","preventDefault","computePreviousId","computeNextId","newOptionValue","findOptionValueById","stopPropagation","inputEvent","document","createEvent","initEvent","dispatchEvent","ctrlKey","metaKey","isKeyCodeCharacterGenerating","keyCode","computeNextValue","isValidValue","handlePaste","clipboardData","getData","handleOptionChange","getAttribute","handleOptionMouseMove","handleMouseDownOutside","useMouseDownOutside","onMouseDownOutside","ref","_jsx","class","createClassName","textboxStyles","textbox","hasBorder","hasIcon","children","_jsxs","inner","input","onFocus","onKeyDown","onPaste","tabIndex","type","border","underline","menuStyles","menu","hidden","textboxAutocompleteStyles","bottom","map","option","index","optionSeparator","optionHeader","header","optionValue","optionValueDisabled","optionValueSelected","checked","onChange","onMouseMove","spellcheck","checkIcon","IconMenuCheckmarkChecked16","doesStringContainSubstring","string","substring","toLowerCase","indexOf","getIndexById","result","findOptionValueAtOrBeforeIndex","findOptionValueAtOrAfterIndex","findLastOptionValue","slice","findFirstOptionValue","reverse","rootElement","rootElementTop","maxHeight","window","innerHeight","style"],"mappings":"0kBAcMA,EAAe,GACfC,EAAa,KACbC,EAA8B,oCAC9BC,EAAuB,GA4CtB,SAASC,GAAyC,CACvDC,SAAAA,EAAW,GACXC,OAAAA,EAAS,GACTC,KAAAA,EACAC,KAAAA,EACAC,QAAAA,EAAU,UAAY,CAAC,EACvBC,aAAAA,EAAe,UAAY,CAAC,EAC5BC,YAAAA,GACAC,uBAAAA,EAAyB,GACzBC,sBAAAA,EAAwB,GACxBC,WAAAA,GAAa,GACbC,OAAAA,EAAS,GACTC,IAAAA,EAAM,GACNC,MAAAA,EACAC,QAAAA,EACA,GAAGC,CACoD,EAAgB,CACvE,GAAI,OAAOZ,GAAS,UAAYA,EAAKa,SAAW,EAC9C,MAAM,IAAIC,MAAO,+CAA8Cd,CAAK,EAAC,EAGjEe,MAAAA,EAA4CC,EAAO,IAAI,EACvDC,EAA+CD,EAAO,IAAI,EAC1DE,EAA4CF,EAAO,IAAI,EAEvD,CAACG,EAAeC,CAAgB,EAAIC,EAAS,EAAK,EAClD,CAACC,EAAYC,CAAa,EAAIF,EAAa3B,CAAU,EACrD,CAAC8B,EAAeC,CAAgB,EAAIJ,EAAS5B,CAAY,EACzD,CAACiC,EAAaC,CAAc,EAAIN,EAAiBX,CAAK,EAExDkB,IAAAA,EAAyBC,GAAcjB,EAAKgB,OAAO,EACnD7B,IAAW,KACH+B,EAAAA,GAAcF,EAASlB,EAAOgB,CAAW,GAM/CK,MAAAA,EAAcC,EAAY,UAAkB,CAChDZ,EAAiB,EAAK,EACtBK,EAAiBhC,CAAY,EAC7BkC,EAAelC,CAAY,EAC3B8B,EAAc7B,CAAU,EACNuB,EAAAA,CAAe,EAAEgB,MACrC,EAAG,CAAE,CAAA,EAGCC,EAAuBF,EAAY,SAAUG,EAAc,CACzDC,MAAAA,EAAcC,EAAkBnB,CAAc,EACpD,GAAIiB,IAAOzC,EAAY,CACrB0C,EAAYE,UAAY,EACxB,MACF,CACA,MAAMC,EAAkBH,EAAYI,cACjC,IAAG7C,CAA4B,KAAIwC,CAAG,IACzC,EACA,GAAII,IAAoB,KAChB,MAAA,IAAIzB,MAAM,qBAAqB,EAEvC,MAAM2B,EACJF,EAAgBG,wBAAwBD,EACxCL,EAAYM,sBAAwBD,EAAAA,EAClCA,GAAAA,EAAIL,EAAYE,UAAW,CAC7BF,EAAYE,UAAYG,EACxB,MACF,CACME,MAAAA,EAAeF,EAAIF,EAAgBK,aACrCD,EAAeP,EAAYE,UAAYF,EAAYQ,eACzCN,EAAAA,UAAYK,EAAeP,EAAYQ,aAEvD,EAAG,CAAE,CAAA,EAECC,EAAoBb,EACxB,SAAUN,EAA2B,CAC7BoB,MAAAA,EAAQC,EAAanB,EAASF,CAAW,EAC/C,GAAIoB,IAAUpD,EAAY,CAExBiC,EAAeD,CAAW,EAC1BH,EAAc7B,CAAU,EACxBwC,EAAqBxC,CAAU,EAC/B,MACF,CAEAiC,EAAelC,CAAY,EAC3B8B,EAAcuB,CAAK,EACnBZ,EAAqBY,CAAK,CAAA,EAE5B,CAAClB,EAASM,CAAoB,CAChC,EAEMc,GAAchB,EAClB,SAAUiB,EAAuD,CAC/D7B,EAAiB,EAAI,EACrB8B,GACEb,EAAkBtB,CAAc,EAChCsB,EAAkBnB,CAAc,EAChCT,CACF,EACAgB,EAAiBf,CAAK,EACtBmC,EAAkBnC,CAAK,EACvB,MAAMyC,EAAeF,EAAMG,cAC3BD,EAAaE,MAAM,EACnBF,EAAaG,OAAO,CAEtB,EAAA,CAAC7C,EAAKoC,EAAmBnC,CAAK,CAChC,EAEM6C,GAAcvB,EAClB,SAAUiB,EAAkD,CACpDO,MAAAA,EAAWP,EAAMG,cAAc1C,MACrCmC,EAAkBW,CAAQ,EAC1BrD,EAAaqD,EAAUvD,CAAI,EAC3BC,EAAQ+C,CAAK,GAEf,CAAChD,EAAMC,EAASC,EAAc0C,CAAiB,CACjD,EAEMY,GAAgBzB,EACpB,SAAUiB,EAA0D,CAClE,MAAME,EAAeF,EAAMG,cACrBM,EAAMT,EAAMS,IACdA,GAAAA,IAAQ,WAAaA,IAAQ,YAAa,CAExC9B,GADJqB,EAAMU,eAAe,EACjB/B,EAAQf,SAAW,EACrB,OAEIiC,MAAAA,EACJY,IAAQ,UACJE,GAAkBhC,EAASN,CAAU,EACrCuC,GAAcjC,EAASN,CAAU,EACvC,GAAIwB,IAAUpD,EAAY,CAExB6B,EAAc7B,CAAU,EACxByD,EAAazC,MAAQgB,EACrBvB,EAAauB,EAAazB,CAAI,EAC9BC,EAAQ+C,CAAK,EACbf,EAAqBxC,CAAU,EAC/B,MACF,CAEA6B,EAAcuB,CAAK,EACnBZ,EAAqBY,CAAK,EACpBgB,MAAAA,EAAiBC,EAAoBnC,EAASkB,CAAK,EACzD,GAAIgB,IAAmB,KACf,MAAA,IAAIhD,MAAM,qBAAqB,EAEvC,MAAM0C,EAAWM,EAAepD,MAChCyC,EAAazC,MAAQ8C,EACrBrD,EAAaqD,EAAUvD,CAAI,EAC3BC,EAAQ+C,CAAK,EACbE,EAAaG,OAAO,EACpB,MACF,CACA,GAAII,IAAQ,SAAWA,IAAQ,UAAYA,IAAQ,MAAO,CAKpDA,GAJJT,EAAMU,eAAe,EACjBtD,IAA2B,IAC7B4C,EAAMe,gBAAgB,EAEpBN,IAAQ,UAAYpD,IAA0B,GAAM,CACtD6C,EAAazC,MAAQc,EACfyC,MAAAA,EAAaC,SAASC,YAAY,OAAO,EACpCC,EAAAA,UAAU,QAAS,GAAM,EAAI,EACxCjB,EAAakB,cAAcJ,CAAU,CACvC,CACYlC,IACZ,MACF,CACA,GAAIvB,IAAW,IAGXyC,EAAAA,EAAMqB,UAAY,IAAQrB,EAAMsB,UAAY,KAG5CC,GAA6BvB,EAAMwB,OAAO,IAAM,GAAM,CAExD,MAAMjB,EAAWkB,EAAiBvB,EAAcF,EAAMS,GAAG,EACrDiB,EAAa/C,EAAS4B,CAAQ,IAAM,IACtCP,EAAMU,eAAe,CAEzB,CAEF,EAAA,CACEjC,EACAzB,EACAC,EACAC,EACAyB,EACAJ,EACAnB,EACAC,EACAgB,EACAd,EACAuB,EACAG,CAAoB,CAExB,EAEM0C,GAAc5C,EAClB,SAAUiB,EAA2D,CACnE,GAAIzC,IAAW,GACb,OAEEyC,GAAAA,EAAM4B,gBAAkB,KACpB,MAAA,IAAI/D,MAAM,iCAAiC,EAE7C0C,MAAAA,EAAWkB,EACfzB,EAAMG,cACNH,EAAM4B,cAAcC,QAAQ,MAAM,CACpC,EACIH,EAAa/C,EAAS4B,CAAQ,IAAM,IACtCP,EAAMU,eAAe,CACvB,EAEF,CAAC/B,EAASpB,CAAM,CAClB,EAEMuE,GAAqB/C,EACzB,SAAUiB,EAAkD,CAC1D,MAAMH,EAAQG,EAAMG,cAAc4B,aAChCrF,CACF,EAEA4B,EAAcuB,CAAK,EACbgB,MAAAA,EAAiBC,EAAoBnC,EAASkB,CAAK,EACzD,GAAIgB,IAAmB,KACf,MAAA,IAAIhD,MAAM,qBAAqB,EAEjCqC,MAAAA,EAAed,EAAkBpB,CAAe,EACtDkC,EAAazC,MAAQoD,EAAepD,MAC9BuD,MAAAA,EAAaC,SAASC,YAAY,OAAO,EACpCC,EAAAA,UAAU,QAAS,GAAM,EAAI,EACxCjB,EAAakB,cAAcJ,CAAU,EACzBlC,GAAA,EAEd,CAACH,EAASG,CAAW,CACvB,EAEMkD,GAAwBjD,EAC5B,SAAUiB,EAAuD,CAC/D,MAAMH,EAAQG,EAAMG,cAAc4B,aAChCrF,CACF,EACImD,IAAUxB,GACZC,EAAcuB,CAAK,CACrB,EAEF,CAACxB,CAAU,CACb,EAEM4D,GAAyBlD,EAC7B,UAAkB,CACZb,IAAkB,IAGVY,GAAA,EAEd,CAACZ,EAAeY,CAAW,CAC7B,EACoB,OAAAoD,GAAA,CAClBC,mBAAoBF,GACpBG,IAAKtE,CAAAA,CACN,EAGCuE,EAAA,MAAA,CACED,IAAKtE,EACLwE,MAAOC,EAAgB,CACrBC,EAAcC,QACd,OAAO/E,EAAY,IACf,KACAA,IAAY,SACZ8E,EAAcE,UACd,KACJ,OAAO3F,EAAS,IAAc,KAAOyF,EAAcG,QACnD9F,IAAa,GAAO2F,EAAc3F,SAAW,IAAI,CAClD,EAAE+F,SAEHC,EAAA,MAAA,CAAKP,MAAOE,EAAcM,MAAMF,UAC9BP,EAAA,QAAA,CAAA,GACM1E,EACJyE,IAAKpE,EACLsE,MAAOE,EAAcO,MACrBlG,SAAUA,IAAa,GACvBG,KAAAA,EACAgG,QAASjD,GACT9C,QAASqD,GACT2C,UAAWzC,GACX0C,QAASvB,GACTxE,YAAAA,GACAgG,SAAUtG,IAAa,GAAO,GAAK,EACnCuG,KAAK,OACL3F,MAAAA,CAAAA,CACD,EACA,OAAOV,EAAS,IAAc,KAC7BsF,EAAA,MAAA,CAAKC,MAAOE,EAAczF,KAAK6F,SAAE7F,CAAAA,CAAU,EAE7CsF,EAAA,MAAA,CAAKC,MAAOE,EAAca,MAAS,CAAA,EAClC3F,IAAY,YACX2E,EAAA,MAAA,CAAKC,MAAOE,EAAcc,SAAAA,CAAY,EACpC,KACJjB,EAAA,MAAA,CACED,IAAKnE,EACLqE,MAAOC,EAAgB,CACrBgB,EAAWC,KACX3G,IAAa,IAAQqB,IAAkB,GACnCqF,EAAWE,OACX,KACJjG,IAAQ,GACJkG,EAA0BlG,IAC1BkG,EAA0BC,MAAM,CACrC,EAAEf,SAEFjE,EAAQiF,IAAI,SAAUC,EAAgBC,EAA4B,CACjE,MAAI,cAAeD,EACVxB,EAAA,KAAA,CAAgBC,MAAOiB,EAAWQ,iBAAzBD,CAA2C,EAEzD,WAAYD,EAEZxB,EAAA,KAAA,CAAgBC,MAAOiB,EAAWS,aAAapB,SAC5CiB,EAAOI,QADDH,CAEL,EAINjB,EAAA,QAAA,CAEEP,MAAOC,EAAgB,CACrBgB,EAAWW,YACXL,EAAOhH,WAAa,GAChB0G,EAAWY,oBACX,KACJN,EAAOhH,WAAa,IAAQgH,EAAO3E,KAAOb,EACtCkF,EAAWa,oBACX,IAAI,CACT,EAAExB,UAEHP,EAAA,QAAA,CAAA,GACM1E,EACJ0G,QAAS5G,IAAUoG,EAAOpG,MAC1B6E,MAAOiB,EAAWR,MAClBlG,SAAUgH,EAAOhH,WAAa,GAC9BG,KAAAA,EACAsH,SAAUxC,GACVyC,YAAavC,GACbwC,WAAYlH,GACZ6F,SAAU,GACVC,KAAK,QACL3F,MAAQ,GAAEoG,EAAOpG,KAAM,GACjB,CAACf,CAA2B,EAAGmH,EAAO3E,EAAAA,CAC7C,EACA2E,EAAOpG,QAAUc,EAChB8D,EAAA,MAAA,CAAKC,MAAOiB,EAAWkB,UAAU7B,SAC/BP,EAACqC,GAA4B,EAAA,CAAA,CAC1B,EACH,KACHb,EAAOpG,KAAK,GA9BRqG,CA+BA,CAAA,CAEV,CAAA,CACE,CAAC,CAAA,CACH,CAAA,CACF,CAET,CAGA,SAASlF,GACPD,EACe,CACf,OAAOA,EAAQiF,IAAI,SACjBC,EACAC,EACQ,CACR,MAAI,UAAWD,EACgC,CAC3C,GAAGA,EACH3E,GAAK,GAAE4E,CAAM,EAAA,EAIVD,CAAAA,CACR,CACH,CAEA,SAAShF,GACPF,EACAlB,EACAgB,EACe,CACf,OAAIhB,IAAUjB,EACLmC,EAEEmB,EAAanB,EAASlB,CAAK,IAC3BhB,EAEFkC,EAAQ7B,OAAO,SAAU+G,EAAyB,CACvD,MAAI,UAAWA,EACNc,EAA2Bd,EAAOpG,MAAOA,CAAK,IAAM,GAEtD,EAAA,CACR,EAGCgB,IAAgBjC,EACXmC,EAGFA,EAAQ7B,OAAO,SAAU+G,EAAyB,CACvD,MAAI,UAAWA,EACNc,EAA2Bd,EAAOpG,MAAOgB,CAAW,IAAM,GAE5D,EAAA,CACR,CACH,CAGA,SAASkG,EACPC,EACAC,EACS,CACT,OAAOD,EAAOE,YAAY,EAAEC,QAAQF,EAAUC,YAAa,CAAA,IAAM,EACnE,CAGA,SAAShF,EAAanB,EAAwBlB,EAAmB,CAC/D,UAAWoG,KAAUlF,EACnB,GAAI,UAAWkF,GACTA,EAAOpG,QAAUA,EACnB,OAAOoG,EAAO3E,GAIbzC,OAAAA,CACT,CAGA,SAASiF,EAAa/C,EAAwBlB,EAAwB,CACpE,GAAIA,IAAUjB,EACL,MAAA,GAET,UAAWqH,KAAUlF,EACnB,GAAI,UAAWkF,GACTA,EAAOpG,MAAMqH,YAAY,EAAEC,QAAQtH,EAAMqH,aAAa,IAAM,EACvD,MAAA,GAIN,MAAA,EACT,CAGA,SAAShE,EACPnC,EACAO,EAC0B,CAC1B,UAAW2E,KAAUlF,EACnB,GAAI,OAAQkF,GAAUA,EAAO3E,KAAOA,EAC3B2E,OAAAA,EAGJ,OAAA,IACT,CAGA,SAASmB,GAAarG,EAAwBO,EAAoB,CAChE,IAAI4E,EAAQ,EACZ,UAAWD,KAAUlF,EAAS,CAC5B,GAAI,OAAQkF,GAAUA,EAAO3E,KAAOA,EAC3B4E,OAAAA,EAEAA,GAAA,CACX,CACO,MAAA,EACT,CAGA,SAASnD,GAAkBhC,EAAwBO,EAAY,CAC7D,GAAIA,IAAOzC,EAAY,CACrB,MAAMwI,EAASC,EAA+BvG,EAASA,EAAQf,OAAS,CAAC,EAClEqH,OAAAA,IAAW,KAAO,KAAOA,EAAO/F,EACzC,CACM4E,MAAAA,EAAQkB,GAAarG,EAASO,CAAE,EACtC,GAAI4E,IAAU,GACZ,MAAM,IAAIjG,MAAO,yBAAwBqB,CAAG,EAAC,EAE/C,GAAI4E,IAAU,EACL,OAAA,KAET,MAAMmB,EAASC,EAA+BvG,EAASmF,EAAQ,CAAC,EACzDmB,OAAAA,IAAW,KAAO,KAAOA,EAAO/F,EACzC,CAGA,SAAS0B,GAAcjC,EAAwBO,EAAY,CACzD,GAAIA,IAAOzC,EAAY,CACfwI,MAAAA,EAASE,EAA8BxG,EAAS,CAAC,EAChDsG,OAAAA,IAAW,KAAO,KAAOA,EAAO/F,EACzC,CACM4E,MAAAA,EAAQkB,GAAarG,EAASO,CAAE,EACtC,GAAI4E,IAAU,GACZ,MAAM,IAAIjG,MAAO,yBAAwBqB,CAAG,EAAC,EAE3C4E,GAAAA,IAAUnF,EAAQf,OAAS,EACtB,OAAA,KAET,MAAMqH,EAASE,EAA8BxG,EAASmF,EAAQ,CAAC,EACxDmB,OAAAA,IAAW,KAAO,KAAOA,EAAO/F,EACzC,CAGA,SAASgG,EACPvG,EACAmF,EAC0B,CAC1B,GAAIA,EAAQ,EACJ,MAAA,IAAIjG,MAAM,aAAa,EAE3BiG,GAAAA,EAAQnF,EAAQf,OAAS,EACrB,MAAA,IAAIC,MAAM,gCAAgC,EAElD,OAAOuH,GAAoBzG,EAAQ0G,MAAM,EAAGvB,EAAQ,CAAC,CAAC,CACxD,CAGA,SAASqB,EACPxG,EACAmF,EAC0B,CAC1B,GAAIA,EAAQ,EACJ,MAAA,IAAIjG,MAAM,aAAa,EAE3BiG,GAAAA,EAAQnF,EAAQf,OAAS,EACrB,MAAA,IAAIC,MAAM,gCAAgC,EAElD,OAAOyH,GAAqB3G,EAAQ0G,MAAMvB,CAAK,CAAC,CAClD,CAGA,SAASwB,GACP3G,EAC0B,CAC1B,UAAWkF,KAAUlF,EACnB,GAAI,OAAQkF,GAAUA,EAAOhH,WAAa,GACjCgH,OAAAA,EAGJ,OAAA,IACT,CAGA,SAASuB,GAAoBzG,EAAkD,CAC7E,OAAO2G,GAAqB3G,EAAQ0G,MAAM,EAAEE,QAAS,CAAA,CACvD,CAEA,SAAStF,GACPuF,EACArG,EACA3B,EACA,CACMiI,MAAAA,EAAiBD,EAAY/F,sBAAAA,EAAwBjC,IACrDkI,EACJlI,IAAQ,GACJiI,EAAiB9I,EACjBgJ,OAAOC,YACPH,EACAD,EAAY7F,aACZhD,EACMkJ,EAAAA,MAAMH,UAAa,GAAEA,CAAU,IAC7C"}