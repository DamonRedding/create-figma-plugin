{"version":3,"file":"raw-textbox-numeric-17858d6f.js","sources":["../../../utilities/lib/number/private/regex.js","../../../utilities/lib/number/evaluate-numeric-expression.js","../../../utilities/lib/number/is-valid-numeric-input.js","../../src/components/textbox/textbox-numeric/private/format-evaluated-value.ts","../../src/components/textbox/textbox-numeric/private/raw-textbox-numeric.tsx"],"sourcesContent":["export const floatOperandRegex = /^-?\\d*(?:\\.\\d*)?$/;\nexport const integerOperandRegex = /^-?\\d*$/;\nexport const operatorRegex = /[+\\-*/]/;\nexport const operatorSuffixRegex = /[+\\-*/]$/;\nexport const numbersRegex = /\\d/;\nexport const invalidCharactersRegex = /[^\\d.+\\-*/]/;\n//# sourceMappingURL=regex.js.map","import { invalidCharactersRegex, numbersRegex, operatorRegex, operatorSuffixRegex } from './private/regex.js';\nexport function evaluateNumericExpression(value) {\n    if (value === '' ||\n        numbersRegex.test(value) === false ||\n        invalidCharactersRegex.test(value) === true) {\n        return null;\n    }\n    if (operatorRegex.test(value) === true) {\n        if (operatorSuffixRegex.test(value) === true) {\n            return eval(value.substring(0, value.length - 1));\n        }\n        return eval(value);\n    }\n    return parseFloat(value);\n}\n//# sourceMappingURL=evaluate-numeric-expression.js.map","import { floatOperandRegex, integerOperandRegex, operatorRegex } from './private/regex.js';\nexport function isValidNumericInput(value, options = { integersOnly: false }) {\n    const split = (value[0] === '-' ? value.substring(1) : value).split(operatorRegex);\n    let i = -1;\n    while (++i < split.length) {\n        const operand = split[i];\n        if ((operand === '' && i !== split.length - 1) ||\n            (options.integersOnly === true\n                ? integerOperandRegex\n                : floatOperandRegex).test(operand) === false) {\n            return false;\n        }\n    }\n    return true;\n}\n//# sourceMappingURL=is-valid-numeric-input.js.map","const EMPTY_STRING = ''\n\nconst fractionalPartRegex = /\\.([^.]+)/\nconst nonDigitRegex = /[^\\d.]/\n\nexport function formatEvaluatedValue(\n  evaluatedValue: null | number,\n  value: string,\n  suffix?: string\n): string {\n  if (evaluatedValue === null) {\n    return EMPTY_STRING\n  }\n  const significantFiguresCount = countSignificantFigures(\n    nonDigitRegex.test(value) === true ? `${evaluatedValue}` : value\n  )\n  return appendSuffix(\n    formatSignificantFigures(evaluatedValue, significantFiguresCount),\n    suffix\n  )\n}\n\nfunction countSignificantFigures(value: string): number {\n  const result = fractionalPartRegex.exec(value)\n  if (result === null) {\n    return 0\n  }\n  return result[1].length\n}\n\nfunction formatSignificantFigures(\n  value: number,\n  significantFiguresCount: number\n): string {\n  if (significantFiguresCount === 0) {\n    return `${value}`\n  }\n  const result = fractionalPartRegex.exec(`${value}`)\n  if (result === null) {\n    return `${value}.${'0'.repeat(significantFiguresCount)}`\n  }\n  const fractionalPart = result[1]\n  const count = significantFiguresCount - fractionalPart.length\n  return `${value}${'0'.repeat(count)}`\n}\n\nfunction appendSuffix(string: string, suffix?: string): string {\n  if (typeof suffix === 'undefined') {\n    return string\n  }\n  if (string === EMPTY_STRING) {\n    return EMPTY_STRING\n  }\n  return `${string}${suffix}`\n}\n","import {\n  evaluateNumericExpression,\n  isValidNumericInput,\n  MIXED_NUMBER,\n  MIXED_STRING\n} from '@create-figma-plugin/utilities'\nimport { h, JSX, RefObject } from 'preact'\nimport { useCallback, useRef, useState } from 'preact/hooks'\n\nimport { OnValueChange, Props } from '../../../../types/types.js'\nimport { getCurrentFromRef } from '../../../../utilities/get-current-from-ref.js'\nimport { computeNextValue } from '../../private/compute-next-value.js'\nimport { isKeyCodeCharacterGenerating } from '../../private/is-keycode-character-generating.js'\nimport { formatEvaluatedValue } from './format-evaluated-value.js'\n\nconst FRACTION_DIGITS = 3\nconst EMPTY_STRING = ''\n\nexport type RawTextboxNumericProps<Name extends string> = {\n  disabled?: boolean\n  incrementBig?: number\n  incrementSmall?: number\n  integer?: boolean\n  maximum?: number\n  minimum?: number\n  name?: Name\n  onInput?: OmitThisParameter<JSX.GenericEventHandler<HTMLInputElement>>\n  onNumericValueInput?: OnValueChange<null | number, Name>\n  onValueInput?: OnValueChange<string, Name>\n  placeholder?: string\n  propagateEscapeKeyDown?: boolean\n  revertOnEscapeKeyDown?: boolean\n  suffix?: string\n  validateOnBlur?: (value: null | number) => null | number | boolean\n  value: string\n}\n\nexport function RawTextboxNumeric<Name extends string>({\n  disabled = false,\n  incrementBig = 10,\n  incrementSmall = 1,\n  integer = false,\n  maximum,\n  minimum,\n  name,\n  onInput = function () {},\n  onNumericValueInput = function () {},\n  onValueInput = function () {},\n  placeholder,\n  propagateEscapeKeyDown = true,\n  revertOnEscapeKeyDown = false,\n  suffix,\n  validateOnBlur,\n  value,\n  ...rest\n}: Props<HTMLInputElement, RawTextboxNumericProps<Name>>): JSX.Element {\n  if (\n    typeof minimum !== 'undefined' &&\n    typeof maximum !== 'undefined' &&\n    minimum >= maximum\n  ) {\n    throw new Error('`minimum` must be less than `maximum`')\n  }\n\n  const inputElementRef: RefObject<HTMLInputElement> = useRef(null)\n  const revertOnEscapeKeyDownRef: RefObject<boolean> = useRef(false) // Boolean flag to exit early from `handleBlur`\n\n  const [originalValue, setOriginalValue] = useState(EMPTY_STRING) // Value of the textbox when it was initially focused\n\n  const setInputElementValue = useCallback(function (value: string): void {\n    const inputElement = getCurrentFromRef(inputElementRef)\n    inputElement.value = value\n    const inputEvent = document.createEvent('Event')\n    inputEvent.initEvent('input', true, true)\n    inputElement.dispatchEvent(inputEvent)\n  }, [])\n\n  const handleBlur = useCallback(\n    function (): void {\n      if (revertOnEscapeKeyDownRef.current === true) {\n        revertOnEscapeKeyDownRef.current = false\n        return\n      }\n      if (typeof validateOnBlur !== 'undefined') {\n        const evaluatedValue = evaluateValue(value, suffix)\n        const result = validateOnBlur(evaluatedValue)\n        if (typeof result === 'number') {\n          // Set to the value returned by `validateOnBlur`\n          setInputElementValue(formatEvaluatedValue(result, value, suffix))\n          setOriginalValue(EMPTY_STRING)\n          return\n        }\n        if (result === null) {\n          // Set value to the empty string\n          setInputElementValue(EMPTY_STRING)\n          setOriginalValue(EMPTY_STRING)\n          return\n        }\n        if (result === false) {\n          // Revert the original value\n          if (value !== originalValue) {\n            setInputElementValue(originalValue)\n          }\n          setOriginalValue(EMPTY_STRING)\n          return\n        }\n      }\n      if (typeof suffix !== 'undefined' && value === suffix) {\n        // We don't want a textbox to contain just the `suffix`, so clear the `value`\n        setInputElementValue(EMPTY_STRING)\n        setOriginalValue(EMPTY_STRING)\n        return\n      }\n      if (value !== EMPTY_STRING && value !== MIXED_STRING) {\n        const evaluatedValue = evaluateValue(value, suffix)\n        const formattedValue = formatEvaluatedValue(\n          evaluatedValue,\n          value,\n          suffix\n        )\n        if (value !== formattedValue) {\n          setInputElementValue(formattedValue)\n        }\n      }\n      setOriginalValue(EMPTY_STRING)\n    },\n    [originalValue, setInputElementValue, suffix, validateOnBlur, value]\n  )\n\n  const handleFocus = useCallback(\n    function (event: JSX.TargetedFocusEvent<HTMLInputElement>): void {\n      setOriginalValue(value)\n      event.currentTarget.select()\n    },\n    [value]\n  )\n\n  const handleInput = useCallback(\n    function (event: JSX.TargetedEvent<HTMLInputElement>) {\n      onInput(event)\n      const value = event.currentTarget.value\n      onValueInput(value, name)\n      const evaluatedValue = evaluateValue(value, suffix)\n      onNumericValueInput(evaluatedValue, name)\n    },\n    [name, onInput, onNumericValueInput, onValueInput, suffix]\n  )\n\n  const handleKeyDown = useCallback(\n    function (event: JSX.TargetedKeyboardEvent<HTMLInputElement>): void {\n      const key = event.key\n      if (key === 'Escape') {\n        if (propagateEscapeKeyDown === false) {\n          event.stopPropagation()\n        }\n        if (revertOnEscapeKeyDown === true) {\n          revertOnEscapeKeyDownRef.current = true\n          setInputElementValue(originalValue)\n          setOriginalValue(EMPTY_STRING)\n        }\n        event.currentTarget.blur()\n        return\n      }\n      if (key === 'Enter') {\n        event.currentTarget.blur()\n        return\n      }\n      const element = event.currentTarget\n      if (key === 'ArrowDown' || key === 'ArrowUp') {\n        const delta = event.shiftKey === true ? incrementBig : incrementSmall\n        if (value === EMPTY_STRING || value === MIXED_STRING) {\n          event.preventDefault()\n          // `startingValue` is biased towards 0\n          const startingValue = (function () {\n            if (typeof minimum !== 'undefined' && minimum > 0) {\n              return minimum\n            }\n            if (typeof maximum !== 'undefined' && maximum < 0) {\n              return maximum\n            }\n            return 0\n          })()\n          const newValue = restrictValue(\n            evaluateValueWithDelta(\n              startingValue,\n              key === 'ArrowDown' ? -1 * delta : delta\n            ),\n            minimum,\n            maximum\n          )\n          const formattedValue = formatEvaluatedValue(newValue, value, suffix)\n          element.value = formattedValue\n          element.select()\n          handleInput(event)\n          return\n        }\n        const evaluatedValue = evaluateValue(value, suffix)\n        if (evaluatedValue === null) {\n          throw new Error('Invariant violation') // `value` is a valid numeric expression\n        }\n        event.preventDefault()\n        const newValue = restrictValue(\n          evaluateValueWithDelta(\n            evaluatedValue,\n            key === 'ArrowDown' ? -1 * delta : delta\n          ),\n          minimum,\n          maximum\n        )\n        const formattedValue = formatEvaluatedValue(newValue, value, suffix)\n        if (formattedValue === value) {\n          return\n        }\n        element.value = formattedValue\n        element.select()\n        handleInput(event)\n        return\n      }\n      if (event.ctrlKey === true || event.metaKey === true) {\n        return\n      }\n      if (isKeyCodeCharacterGenerating(event.keyCode) === true) {\n        // Piece together `nextValue` using the key that was pressed, and stop\n        // the `keyDown` event (by calling `event.preventDefault()`) if\n        // `newValue` is found to be invalid\n        const nextValue = trimSuffix(\n          value === MIXED_STRING\n            ? event.key\n            : computeNextValue(element, event.key),\n          suffix\n        )\n        if (\n          isValidNumericInput(nextValue, { integersOnly: integer }) === false\n        ) {\n          event.preventDefault()\n          return\n        }\n        if (typeof minimum === 'undefined' && typeof maximum === 'undefined') {\n          return\n        }\n        const evaluatedValue = evaluateNumericExpression(nextValue)\n        if (evaluatedValue === null) {\n          return\n        }\n        if (\n          (typeof minimum !== 'undefined' && evaluatedValue < minimum) ||\n          (typeof maximum !== 'undefined' && evaluatedValue > maximum)\n        ) {\n          event.preventDefault()\n        }\n      }\n    },\n    [\n      handleInput,\n      incrementBig,\n      incrementSmall,\n      integer,\n      maximum,\n      minimum,\n      originalValue,\n      propagateEscapeKeyDown,\n      revertOnEscapeKeyDown,\n      setInputElementValue,\n      suffix,\n      value\n    ]\n  )\n\n  const handleMouseUp = useCallback(\n    function (event: JSX.TargetedMouseEvent<HTMLInputElement>): void {\n      if (value !== MIXED_STRING) {\n        return\n      }\n      event.preventDefault()\n    },\n    [value]\n  )\n\n  const handlePaste = useCallback(\n    function (event: JSX.TargetedClipboardEvent<HTMLInputElement>): void {\n      if (event.clipboardData === null) {\n        throw new Error('`event.clipboardData` is `null`')\n      }\n      const nextValue = trimSuffix(\n        computeNextValue(\n          event.currentTarget,\n          event.clipboardData.getData('Text')\n        ),\n        suffix\n      )\n      if (\n        isValidNumericInput(nextValue, {\n          integersOnly: integer\n        }) === false\n      ) {\n        event.preventDefault()\n      }\n    },\n    [integer, suffix]\n  )\n\n  return (\n    <input\n      {...rest}\n      ref={inputElementRef}\n      disabled={disabled === true}\n      name={name}\n      onBlur={handleBlur}\n      onFocus={handleFocus}\n      onInput={handleInput}\n      onKeyDown={handleKeyDown}\n      onMouseUp={handleMouseUp}\n      onPaste={handlePaste}\n      placeholder={placeholder}\n      spellcheck={false}\n      tabIndex={disabled === true ? -1 : 0}\n      type=\"text\"\n      value={value === MIXED_STRING ? 'Mixed' : value}\n    />\n  )\n}\n\nfunction restrictValue(value: number, minimum?: number, maximum?: number) {\n  if (typeof minimum !== 'undefined') {\n    if (typeof maximum !== 'undefined') {\n      // both `minimum` and `maximum` are defined\n      return Math.min(Math.max(value, minimum), maximum)\n    }\n    // only `minimum` is defined\n    return Math.max(value, minimum)\n  }\n  if (typeof maximum !== 'undefined') {\n    // only `maximum` is defined\n    return Math.min(value, maximum)\n  }\n  // both `minimum` and `maximum` are `undefined`\n  return value\n}\n\nfunction evaluateValue(value: string, suffix?: string): null | number {\n  if (value === MIXED_STRING) {\n    return MIXED_NUMBER\n  }\n  if (value === EMPTY_STRING) {\n    return null\n  }\n  return evaluateNumericExpression(trimSuffix(value, suffix))\n}\n\nfunction evaluateValueWithDelta(value: number, delta: number): number {\n  return parseFloat((value + delta).toFixed(FRACTION_DIGITS))\n}\n\nfunction trimSuffix(string: string, suffix?: string): string {\n  if (typeof suffix === 'undefined') {\n    return string\n  }\n  return string.replace(new RegExp(`${suffix}$`), EMPTY_STRING)\n}\n"],"names":["floatOperandRegex","integerOperandRegex","operatorRegex","operatorSuffixRegex","numbersRegex","invalidCharactersRegex","evaluateNumericExpression","value","test","eval","substring","length","parseFloat","isValidNumericInput","options","integersOnly","split","i","operand","EMPTY_STRING","fractionalPartRegex","nonDigitRegex","formatEvaluatedValue","evaluatedValue","suffix","significantFiguresCount","countSignificantFigures","appendSuffix","formatSignificantFigures","result","exec","repeat","fractionalPart","count","string","FRACTION_DIGITS","RawTextboxNumeric","disabled","incrementBig","incrementSmall","integer","maximum","minimum","name","onInput","onNumericValueInput","onValueInput","placeholder","propagateEscapeKeyDown","revertOnEscapeKeyDown","validateOnBlur","rest","Error","inputElementRef","useRef","revertOnEscapeKeyDownRef","originalValue","setOriginalValue","useState","setInputElementValue","useCallback","inputElement","getCurrentFromRef","inputEvent","document","createEvent","initEvent","dispatchEvent","handleBlur","current","evaluateValue","MIXED_STRING","formattedValue","handleFocus","event","currentTarget","select","handleInput","handleKeyDown","key","stopPropagation","blur","element","delta","shiftKey","preventDefault","startingValue","newValue","restrictValue","evaluateValueWithDelta","ctrlKey","metaKey","isKeyCodeCharacterGenerating","keyCode","nextValue","trimSuffix","computeNextValue","handleMouseUp","handlePaste","clipboardData","getData","_jsx","ref","onBlur","onFocus","onKeyDown","onMouseUp","onPaste","spellcheck","tabIndex","type","Math","min","max","MIXED_NUMBER","toFixed","replace","RegExp"],"mappings":"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"}